/*
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.10.0
 */
package org.integratedmodelling.kim.validation

import java.util.EnumSet
import java.util.List
import java.util.logging.Level
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.util.Tuples
import org.eclipse.xtext.validation.Check	
import org.integratedmodelling.kim.api.BinarySemanticOperator
import org.integratedmodelling.kim.api.IKimConcept
import org.integratedmodelling.kim.api.IKimConcept.Type
import org.integratedmodelling.kim.api.IKimConceptStatement.DescriptionType
import org.integratedmodelling.kim.api.IKimMacro
import org.integratedmodelling.kim.api.IKimMacro.Field
import org.integratedmodelling.kim.kdecl.Concept
import org.integratedmodelling.kim.kdecl.ConceptDeclaration
import org.integratedmodelling.kim.kdecl.ConceptStatement
import org.integratedmodelling.kim.kdecl.ConceptStatementBody
import org.integratedmodelling.kim.kdecl.KdeclPackage
import org.integratedmodelling.kim.kdecl.ObservableSemantics
import org.integratedmodelling.kim.model.Kim
import org.integratedmodelling.kim.model.Kim.ConceptDescriptor
import org.integratedmodelling.kim.model.KimAnnotation
import org.integratedmodelling.kim.model.KimConceptStatement
import org.integratedmodelling.kim.model.KimConceptStatement.ParentConcept
import org.integratedmodelling.kim.model.KimMacro
import org.integratedmodelling.kim.model.KimMetadata
import org.integratedmodelling.kim.model.KimNamespace

/**
 * Validation and type resolution for concept declarations. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class KnowledgeDeclarationValidator extends AbstractKnowledgeDeclarationValidator {

	@Check
	def checkConceptDeclaration(ConceptDeclaration concept) {
		/*
		 * TODO condition to flag set in top-level model validator so we can avoid double validation
		 * when we validate a model
		 * if (!Kim.validatingModel()) {...}
		 */
		var type = checkDeclaration(concept)
		if (type.isEmpty) {
			// warning?
		}
	}

	@Check
	def checkObservableSemantics(ObservableSemantics semantics) {

		if (semantics.role !== null) {
			var role = checkConcept(semantics.role, null, null)
			if (!role.contains(Type.ROLE)) {
				error("Only roles can be used in the 'as' specification of an observable", semantics.role, null,
					KdeclPackage.OBSERVABLE_SEMANTICS__ROLE)
			}
		}

		var declaration = Kim.INSTANCE.declareConcept(semantics.declaration)

		if (declaration !== null) {

			if (semantics.unit !== null) {
				if (!declaration.is(Type.INTENSIVE_PROPERTY) && !declaration.is(Type.EXTENSIVE_PROPERTY) &&
					!declaration.is(Type.NUMEROSITY)) {
					error("Units can only be specified for physical properties or counts", semantics.unit, null,
						KdeclPackage.OBSERVABLE_SEMANTICS__UNIT)
				} else {
					// TODO check unit (callback?) - must be extentual for counts, length or duration for distance, anything appropriate for phys props
				}
			}
			if (semantics.currency !== null) {
				if (!declaration.is(Type.MONEY)) {
					error("Currencies can only be specified for monetary values", semantics.currency, null,
						KdeclPackage.OBSERVABLE_SEMANTICS__CURRENCY)
				}
			}

			/*
			 * Range is only allowed for numeric qualities where it's not already implicit
			 */
			if (semantics.from !== null) {
				if (declaration.is(Type.PROPORTION) || declaration.is(Type.PROBABILITY) || declaration.is(Type.ANGLE) ||
					declaration.is(Type.OCCURRENCE)) {
					error("Numeric range can not be specified for proportions, percentages, probabilities and angles",
						semantics.from, null, KdeclPackage.OBSERVABLE_SEMANTICS__FROM)
				} else if (!declaration.is(Type.QUALITY) || declaration.is(Type.CLASS) ||
					declaration.is(Type.PRESENCE)) {
					error("Numeric ranges can only be specified for numeric qualities", semantics.from, null,
						KdeclPackage.OBSERVABLE_SEMANTICS__FROM)
				}
			}

		}
	}

	def EnumSet<Type> checkDeclaration(ConceptDeclaration declaration) {

		var type = EnumSet.noneOf(Type)
		var error = false
		var flags = EnumSet.noneOf(Type)
		var subjective = false
		var template = false
		var KimMacro macro = null;

		for (main : declaration.main) {

			var mmacro = new KimMacro();

			// this sets the macro to non-empty if the concept is a macro. In that case the 'is' in the
			// macro stands for a definition.
			flags = checkConcept(main, declaration, mmacro)

			if (flags.isEmpty) {
				type.clear
				error = true
			} else {

				// seen anything subjective?
				if (flags.contains(Type.SUBJECTIVE)) {
					subjective = true
				}

				if (flags.contains(Type.MACRO)) {
					template = true
				}

				if (flags.contains(Type.OBSERVABLE) || flags.contains(Type.CONFIGURATION)) {
					if (type.contains(Type.OBSERVABLE) || type.contains(Type.CONFIGURATION)) {
						error(
							"Concept declarations can only contain one observable (quality, process, subject, event or relationship) or configuration",
							main, null, KdeclPackage.CONCEPT_DECLARATION__MAIN)
						error = true
					} else {
						type = flags;
					}
				}

				if (!mmacro.isEmpty) {

					if (macro !== null) {
						error(
							"Only one macro can be used in a concept expression: cannot use " + macro.name + " with " +
								mmacro.name, main, null, KdeclPackage.CONCEPT_DECLARATION__MAIN)
						error = true
					} else {

						macro = mmacro;

						/*
						 * check that all the requested fields are defined
						 */
						for (field : mmacro.fields) {

							var mtype = mmacro.getType(field)
							var description = Kim.getTypeDescription(mtype.type)
							if (mtype.descriptor !== null) {
								description += " (" + mtype.descriptor.name + ")";
							}

							switch (field) {
								case CAUSANT: {
									if (!mtype.isOptional && declaration.causant === null) {
										error(
											"Macro " + mmacro.name +
												" requires a causant ('from ...') concept of type " + description, main,
											null, KdeclPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case CAUSED: {
									if (!mtype.isOptional && declaration.caused === null) {
										error(
											"Macro " + mmacro.name + " requires a caused ('to ...') concept of type " +
												description, main, null, KdeclPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case COMPRESENT: {
									if (!mtype.isOptional && declaration.compresent === null) {
										error(
											"Macro " + mmacro.name +
												" requires a compresent ('with ...') concept of type " + description,
											main, null, KdeclPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case CONTEXT: {
									if (!mtype.isOptional && declaration.context === null) {
										error(
											"Macro " + mmacro.name +
												" requires a context ('within ...') concept of type " + description,
											main, null, KdeclPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case GOAL: {
									if (!mtype.isOptional && declaration.motivation === null) {
										error("Macro " + mmacro.name + " requires a goal ('for ...') concept of type " +
											description, main, null, KdeclPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case INHERENT: {
									if (!mtype.isOptional && declaration.inherency === null) {
										error(
											"Macro " + mmacro.name +
												" requires an inherent ('of ...') concept of type " + description, main,
											null, KdeclPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
							}
						}
					}
				}
			}
		}

		// no observable but valid declaration, e.g. trait only: last concept is the flags
		// keep subjective status if seen anywhere
		if (!error && type.isEmpty) {
			type = flags
		}

		if (!type.isEmpty) {
			if (subjective) {
				type.add(Type.SUBJECTIVE)
			}
			if (template) {
				type.add(Type.MACRO)
			}
		}

		if (declaration.inherency !== null) {
			if (flags.contains(Type.EXTENT)) {
				// TODO restrict to worldviews as this is pretty fundamental
			} else if (!flags.contains(Type.OBSERVABLE) && !flags.contains(Type.CONFIGURATION)) {
				error("Only observables and configurations can have inherency", declaration.inherency, null,
					KdeclPackage.CONCEPT_DECLARATION__INHERENCY)
			}
			flags = checkDeclaration(declaration.inherency)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.INHERENT)) {
					// check against required field type
					var rtype = macro.getType(Field.INHERENT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error(
							"The inherent type (of) does not match the type requested by the " + macro.name + " macro",
							declaration.inherency, null, KdeclPackage.CONCEPT_DECLARATION__INHERENCY)
						error = true
					} else {
						macro.setField(Field.INHERENT, declaration.inherency)
					}
				} else {
					if (!flags.contains(Type.DIRECT_OBSERVABLE) && !flags.contains(Type.CONFIGURATION)) {
						error(
							"The inherent type (of) must be a direct observable (process, subject, event or relationship) or a configuration",
							declaration.inherency, null, KdeclPackage.CONCEPT_DECLARATION__INHERENCY)
						error = true
					}
				}
			}
			copyInheritableFlags(flags, type);
		}

		if (declaration.context !== null) {
			if (!type.contains(Type.OBSERVABLE)) {
				error("Only observables can have context", declaration.context, null,
					KdeclPackage.CONCEPT_DECLARATION__INHERENCY)
			}
			flags = checkDeclaration(declaration.context)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.CONTEXT)) {
					// check against required field type
					var rtype = macro.getType(Field.CONTEXT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The context type (within) does not match the type requested by the " + macro.name +
							" macro", declaration.context, null, KdeclPackage.CONCEPT_DECLARATION__CONTEXT)
						error = true
					} else {
						macro.setField(Field.CONTEXT, declaration.context)
					}
				} else {
					if (!flags.contains(Type.COUNTABLE)) {
						error("The context type (within) must be a subject, event or relationship",
							declaration.context, null, KdeclPackage.CONCEPT_DECLARATION__CONTEXT)
					}
				}
			}
			copyInheritableFlags(flags, type);
		}

		if (declaration.compresent !== null) {
			flags = checkDeclaration(declaration.compresent)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.COMPRESENT)) {
					// check against required field type
					var rtype = macro.getType(Field.COMPRESENT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The compresent type (with) does not match the type requested by the " + macro.name +
							" macro", declaration.compresent, null, KdeclPackage.CONCEPT_DECLARATION__COMPRESENT)
						error = true
					} else {
						macro.setField(Field.COMPRESENT, declaration.compresent)
					}
				} else {
//					if (!flags.contains(Type.COUNTABLE)) {
//						error("The context type (within) must be a subject, event or relationship",
//							declaration.context, null, KdeclPackage.CONCEPT_DECLARATION__CONTEXT)
//					}
				}
			}
			copyInheritableFlags(flags, type);
		}
		if (declaration.causant !== null) {
			flags = checkDeclaration(declaration.causant)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.CAUSANT)) {
					// check against required field type
					var rtype = macro.getType(Field.CAUSANT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The causant type (from) does not match the type requested by the " + macro.name +
							" macro", declaration.causant, null, KdeclPackage.CONCEPT_DECLARATION__CAUSANT)
						error = true
					} else {
						macro.setField(Field.CAUSANT, declaration.causant)
					}
				} else {
//					if (!flags.contains(Type.COUNTABLE)) {
//						error("The context type (within) must be a subject, event or relationship",
//							declaration.context, null, KdeclPackage.CONCEPT_DECLARATION__CONTEXT)
//					}
				}
			}
			copyInheritableFlags(flags, type);
		}
		if (declaration.caused !== null) {
			flags = checkDeclaration(declaration.caused)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.CAUSED)) {
					// check against required field type
					var rtype = macro.getType(Field.CAUSED);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The caused type (to) does not match the type requested by the " + macro.name + " macro",
							declaration.caused, null, KdeclPackage.CONCEPT_DECLARATION__CAUSED)
						error = true
					} else {
						macro.setField(Field.CAUSED, declaration.caused)
					}
				} else {
//					if (!flags.contains(Type.COUNTABLE)) {
//						error("The context type (within) must be a subject, event or relationship",
//							declaration.context, null, KdeclPackage.CONCEPT_DECLARATION__CONTEXT)
//					}
				}
			}
			copyInheritableFlags(flags, type);
		}
		if (declaration.motivation !== null) {
			flags = checkDeclaration(declaration.motivation)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.GOAL)) {
					// check against required field type
					var rtype = macro.getType(Field.GOAL);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The goal type (for) does not match the type requested by the " + macro.name + " macro",
							declaration.motivation, null, KdeclPackage.CONCEPT_DECLARATION__MOTIVATION)
						error = true
					} else {
						macro.setField(Field.GOAL, declaration.motivation)
					}
				} else {
//					if (!flags.contains(Type.COUNTABLE)) {
//						error("The context type (within) must be a subject, event or relationship",
//							declaration.context, null, KdeclPackage.CONCEPT_DECLARATION__CONTEXT)
//					}
				}
			}
			copyInheritableFlags(flags, type);
		}

		if (!type.isEmpty) {
			var i = 0
			for (operand : declaration.operands) {
				var otype = checkDeclaration(operand)
				if (!Kim.isCompatible(type, otype)) {
					error("Operands in the '" + declaration.operators.get(i) + "' expression are of incompatible types",
						operand, KdeclPackage.Literals.CONCEPT_DECLARATION__OPERANDS, i)
					error = true
				}
				i++
			}
		}

		if (!error && !type.isEmpty && declaration.name === null) {
			var d = Kim.INSTANCE.declareConcept(declaration, macro)
			declaration.name = if(d === null) null else d.getDefinition()
		}

		return type
	}

	def copyInheritableFlags(EnumSet<Type> from, EnumSet<Type> to) {
		if (from.contains(Type.SUBJECTIVE)) {
			to.add(Type.SUBJECTIVE)
		}
		if (from.contains(Type.MACRO)) {
			to.add(Type.MACRO)
		}
	}

	/**
	 * Return the flags for the declaration; 0 = undefined
	 */
	def EnumSet<Type> checkConcept(Concept concept, ConceptDeclaration declaration, IKimMacro macro) {

		var ret = EnumSet.noneOf(Type)

		if (concept.declaration !== null) {

			return checkDeclaration(concept.declaration)

		} else if (concept.name !== null) {

			if (concept.name.isTemplate) {

				ret.add(Type.MACRO)
				if (concept.name.extends !== null) {
					// add type for extended concept if any
					val ext = checkConcept(concept.name.extends, declaration, macro)
					if (ext.isEmpty) {
						ret.clear
					} else {
						ret.addAll(ext)
					}
				} else if (concept.name.type !== null) {
					ret.addAll(Kim.INSTANCE.getType(concept.name.type))
				}

			} else {

				if (!concept.name.name.contains(":")) {
					var namespace = KimValidator.getNamespace(concept);
					concept.name.name = (if(namespace === null) "UNDEFINED" else namespace.getName()) + ":" +
						concept.name.name
				}

				// extract concept
				var cd = Kim.INSTANCE.getConceptDescriptor(concept.name.name);

				if (cd !== null) {

					ret.addAll(cd.flags)
					if (cd.is(Type.MACRO)) {
						ret.remove(Type.MACRO)
						(macro as KimMacro).set(cd.getMacro());
					}

					if (concept.isNegated && !(cd.is(Type.DENIABLE) || cd.is(Type.EVENT))) {
						// TODO 'not event' may need further validation (e.g. in probabilities or occurrences)
						error("Concept " + concept.name + " is not a deniable attribute or an event", concept, null,
							KdeclPackage.CONCEPT__NEGATED)
					}

				// validation of authority is left to the reasoner for now
				}
			}

		} else if (concept.concept !== null) {

			// get the cd for the main observable; if no observable, skip
			var flags = checkDeclaration(concept.concept)

			if (!flags.isEmpty) {

				var operator = EnumSet.noneOf(Type)

				// validate operator if any and transform the observable accordingly
				if (concept.isCount) {
					if (!flags.contains(Type.COUNTABLE)) {
						// must be countable
						error(concept.concept.name + " is not a countable observable (subject, event or relationship)",
							concept.concept, null, KdeclPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.NUMEROSITY)
				} else if (concept.isDistance) {
					if (!flags.contains(Type.COUNTABLE)) {
						error("Distance can only be computed relative to countables", concept.concept, null,
							KdeclPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.DISTANCE)
				} else if (concept.isOccurrence || concept.isPresence) {
					if (!flags.contains(Type.DIRECT_OBSERVABLE)) {
						error((if(concept.isOccurrence) 'Occurrence' else 'Presence') +
							" can only be assessed for direct observables (subjects, events, processes and relationships)",
							concept.concept, null, KdeclPackage.CONCEPT__CONCEPT)
					}
					if (concept.isOccurrence) {
						operator.add(Type.OCCURRENCE);
						operator.add(Type.PROBABILITY)
					} else {
						operator.add(Type.PRESENCE)
					}
				} else if (concept.isProbability) {
					if (!flags.contains(Type.EVENT)) {
						error("Probability only applies to events" + (
								if(flags.contains(
							Type.DIRECT_OBSERVABLE)) "; use occurrence for probability of presence" else ""),
							concept.concept, null, KdeclPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.PROBABILITY)
				} else if (concept.isProportion) {
					operator.add(Type.PROPORTION)
				} else if (concept.isRatio) {

//						            if (!(NS.isQuality(ret) || NS.isTrait(ret)) && !NS.isQuality(other)) {
//						context.error(cid.getId() + " ratios are of qualities over qualities or traits over qualities",
//							lineNumber(cid));
//						return KLAB.KM.getNothing();
//					}
					operator.add(Type.RATIO)
				} else if (concept.isValue) {
					operator.add(Type.VALUE)
				} else if (concept.isUncertainty) {
					if (!flags.contains(Type.QUALITY)) {
						error(
							"Uncertainty is associated to qualities. Use probability or occurrence for other observables",
							concept.concept, null, KdeclPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.UNCERTAINTY)
				} // TODO add observability and type
				if (!operator.isEmpty) {
					ret = Kim.INSTANCE.makeQuality(ret, operator.toArray(newArrayOfSize(operator.size())))
					if (flags.contains(Type.MACRO)) {
						ret.add(Type.MACRO)
					}
					if (flags.contains(Type.SUBJECTIVE)) {
						ret.add(Type.SUBJECTIVE)
					}
				}

			/*
			 * set flags
			 */
			} else {
				ret.clear
			}

		}

		return ret
	}

	@Check
	def checkConceptDefinition(ConceptStatement statement) {

		var ok = true
		var ns = KimValidator.getNamespace(statement);
		if (ns !== null && ns.isWorldviewBound) {
			error('Concept definitions are not admitted in sidecar files',
				KdeclPackage.Literals.CONCEPT_STATEMENT__BODY)
			ok = false;
		}

		var EnumSet<Type> type = Kim.INSTANCE.getType(statement.concept)

		if (statement.isAbstract) {
			type.add(Type.ABSTRACT)
		}

		if (statement.isDeniable) {
			if (!type.contains(Type.ATTRIBUTE) || type.contains(Type.ORDERING)) {
				error('Only attributes can be deniable', KdeclPackage.Literals.CONCEPT_STATEMENT__DENIABLE)
				ok = false
			} else {
				type.add(Type.DENIABLE)
			}
		}

		if (statement.isSubjective) {
			if (!type.contains(Type.ATTRIBUTE)) {
				error('Only attributes can be subjective', KdeclPackage.Literals.CONCEPT_STATEMENT__SUBJECTIVE)
				ok = false
			} else {
				type.add(Type.SUBJECTIVE)
			}
		}

		if (statement.agentSpecifier !== null) {
			if (!type.contains(Type.AGENT)) {
				error('modifier ' + statement.agentSpecifier + " only applies to agents",
					KdeclPackage.Literals.CONCEPT_STATEMENT__AGENT_SPECIFIER)
				ok = false
			} else {
				type.add(switch (statement.agentSpecifier) {
					case "deliberative": Type.DELIBERATIVE
					case "interactive": Type.INTERACTIVE
					case "reactive": Type.REACTIVE
				})
			}
		}

		if (statement.propertySpecifiers !== null) {
			var i = 0;
			for (specifier : statement.propertySpecifiers) {
				if (!type.contains(Type.RELATIONSHIP)) {
					error('modifier ' + specifier + " only applies to relationships",
						KdeclPackage.Literals.CONCEPT_STATEMENT__PROPERTY_SPECIFIERS, i)
					ok = false
				} else {
					type.add(switch (specifier) {
						case "functional": Type.FUNCTIONAL
						case "structural": Type.STRUCTURAL
						case "unidirectional": Type.UNIDIRECTIONAL
						case "bidirectional": Type.BIDIRECTIONAL
					})
				}
				i++
			}
		}

		if (ok && statement.body !== null) {

			var namespace = Kim.INSTANCE.getNamespace(statement, true)
			var concept = validateConceptBody(statement.body, namespace, null, type)
			if (concept !== null) {
				statement.name = namespace.name + ":" + statement.body.name;
				var i = 0
				for (annotation : statement.annotations) {
					val ann = new KimAnnotation(annotation, namespace)
					concept.annotations.add(ann)
					for (notification : ann.validateUsage(ann)) {
						notify(notification, statement, KdeclPackage.Literals.CONCEPT_STATEMENT__ANNOTATIONS, i)
					}
					i++
				}
			}
		}
	}

//	@Check
//	def validateAnnotation(Annotation ann) {
//		val namespace = Kim.INSTANCE.getNamespace(ann, true)
//		val annot = new KimAnnotation(ann, namespace)
//		for (notification : annot.validateUsage(null as IKimStatement)) {
//			notify(notification, ann, KdeclPackage.Literals.ANNOTATION__NAME, 0)
//		}
//	}

	def KimConceptStatement validateConceptBody(ConceptStatementBody concept, KimNamespace namespace,
		KimConceptStatement parent, EnumSet<Type> type) {

		var KimConceptStatement ret = new KimConceptStatement(concept)
		var ok = true
		var isAlias = concept.alias
		var List<ParentConcept> declaredParents = newArrayList
		var template = false

		if (Kim.INSTANCE.getConceptDescriptor(namespace.name + ":" + concept.name) !== null) {
			error('A concept can only be declared once', concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__NAME)
		}

		// parents now (validate only)
		if (concept.parents.size() > 0) {

			var error = false

			if (concept.isCoreConcept) {
				// must be one only and is validated outside the
				// syntax checker
				if (!namespace.isWorldviewRoot()) {
					error('Using core concept is reserved for the root namespace of a worldview', concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
					error = true
				} else if (concept.parents.size() > 1 || concept.parents.get(0).main.size() != 1 ||
					concept.parents.get(0).main.get(0).name === null) {
					error('Core concepts can only be declared as a single, simple inheritance', concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
					error = true
				} else {
					var coreconcept = concept.parents.get(0).main.get(0).name.name
					var corectype = Kim.INSTANCE.getType((concept.eContainer as ConceptStatement).concept)
					var a = Kim.intersection(type, IKimConcept.DECLARABLE_TYPES);
					var b = Kim.intersection(corectype, IKimConcept.DECLARABLE_TYPES);
					if (a.size() != 1 || b.size() != 1 || a.get(0) != b.get(0)) {
						error('Core concept is not compatible with the stated type', concept,
							KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
						error = true
					} else {
						type.addAll(corectype)
						var coretype = Kim.INSTANCE.checkCoreConcept(coreconcept, type)
						if (coretype.isEmpty) {
							error('Core concept is not compatible with the stated type', concept,
								KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
							error = true
						} else {
							ret.type.addAll(coretype)
							Kim.INSTANCE.declareCoreConceptPeer(namespace.getName() + ":" + concept.name, coreconcept)
							ret.upperConceptDefined = coreconcept
						}
					}
				}
			} else {

				// not allowed in nested specs
				if (parent !== null) {
					error('Cannot attribute parents to a non-top level child concept. Use "inherits" to add traits.',
						concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
					ok = false
				}
				var i = 0
				for (p : concept.parents) {

					var ptype = checkDeclaration(p)
					var ctype = EnumSet.copyOf(type);
					ctype.addAll(ptype)

					if (Kim.intersection(ctype, IKimConcept.DECLARABLE_TYPES).size() != 1) {
						error('This is not a suitable parent for the declared type', concept,
							KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
						error = true
					} else if (ctype.contains(Type.QUALITY) &&
						Kim.intersection(ctype, IKimConcept.QUALITY_TYPES).size() != 1) {
						error('This is not a suitable parent quality for the declared type', concept,
							KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
						error = true
					} else if (ctype.contains(Type.TRAIT) &&
						Kim.intersection(ctype, IKimConcept.TRAIT_TYPES).size() != 1) {
						error('This is not a suitable parent trait for the declared type', concept,
							KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
						error = true
					} else if (!ptype.isEmpty) {

						var declaration = Kim.INSTANCE.declareConcept(p);
						if (declaration !== null && !declaration.type.isEmpty) {

							if (i == 0 || concept.connectors.get(i - 1) == ',') {
								var group = new ParentConcept();
								group.concepts.add(declaration)
								declaredParents.add(group)
							} else {
								var group = declaredParents.get(declaredParents.size() - 1)
								group.concepts.add(declaration)
								var statedConnector = concept.connectors.get(i - 1)
								var connector = if (statedConnector.equals("or"))
										BinarySemanticOperator.UNION
									else if (statedConnector.equals("and"))
										BinarySemanticOperator.INTERSECTION
									else if (statedConnector.equals("follows"))
										BinarySemanticOperator.FOLLOWS
								if (connector == BinarySemanticOperator.FOLLOWS &&
									!declaration.type.contains(Type.EVENT)) {
									error("The consequentiality ('follows') operator is only allowed between events",
										concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
									error = true
								}
								if (group.connector !== BinarySemanticOperator.NONE && group.connector != connector) {
									error(
										"Cannot mix union ('or'), intersection ('and') and consequentiality ('follows') operators",
										concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
									error = true
								} else {
									group.connector = connector
								}
							}
						}
					} else {
						error("Can't inherit from an undefined concept", concept,
							KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
						error = true
					}

					if (!error) {
						type.addAll(ptype)
					}
					if (ptype.contains(Type.MACRO)) {
						template = true
					}

					i++
				}
			}

			ok = !error

		} else if (concept.isNothing) {
			type.add(Type.NOTHING)
		}

		ret.getParents().addAll(declaredParents)

		// children now
		if (concept.children.size() > 0) {
			if (isAlias) {
				error("A concept declared as an equivalence ('equals') cannot have children.", concept,
					KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__CHILDREN)
				ok = false
			} else {
				for (child : concept.children) {
					var childsc = validateConceptBody(child, namespace, ret, type)
					if (childsc === null) {
						ok = false
					} else {
						ret.getChildren().add(childsc)
					}
				}
			}
		}

		if (concept.authority !== null) {
			ret.setAuthority(concept.authority);
			if (concept.stringIdentifier !== null) {
				ret.setAuthorityTerm(concept.stringIdentifier)
			} else {
				ret.setAuthorityTerm(concept.intIdentifier + "")
			}
		}

		if (concept.actuallyInheritedTraits.size > 0) {
			var i = 0
			for (ConceptDeclaration trait : concept.actuallyInheritedTraits) {
				var ttype = checkDeclaration(trait)
				if (!ttype.contains(Type.TRAIT)) {
					error("Only traits can be inherited", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__ACTUALLY_INHERITED_TRAITS, i)
					ok = false
				} else {
					ret.traitsInherited.add(Kim.INSTANCE.declareConcept(trait));
				}
				i++
			}
		}

		if (concept.contextualizedTraits.size > 0) {

			if (!type.contains(Type.CLASS)) {
				error("Only a class can expose traits", concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__CHILDREN)
				ok = false

			} else {

				// TODO exposes or exposing, use concept.specific to distinguish
				var i = 0
				for (ObservableSemantics trait : concept.contextualizedTraits) {
					var ttype = checkDeclaration(trait.declaration)
					if (!ttype.contains(Type.TRAIT)) {
						error("Only traits can be exposed by classes", concept,
							KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__ACTUALLY_INHERITED_TRAITS, i)
						ok = false
					} else {
						ret.traitsExposed.add(Kim.INSTANCE.declareObservable(trait));
					}
					i++
				}

				ret.definingExposedTraits = !concept.specific
			}
		}

		if (concept.definedAuthority !== null) {
//			ret.authorityDefined
//			concept.definedAuthority
		}

		for (requirement : concept.requirements) {
			// TODO IdentityRequirementList
		}

		if (concept.describedQuality !== null) {
			if (!type.contains(Type.ATTRIBUTE) && !type.contains(Type.REALM) && !type.contains(Type.ORDERING) &&
				!type.contains(Type.QUALITY)) {
				error("The 'describes' clause can only be stated by attributes, orderings, realms and qualities",
					concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.describedQuality)
			if (!(type.contains(Type.REALM) && ttype.contains(Type.EXTENT)) && !ttype.contains(Type.QUALITY)) {
				error(if (type.contains(Type.REALM))
					"Realms can describe only extents or qualities"
				else
					"Only qualities can be described by attributes", concept,
					KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Tuples.create(Kim.INSTANCE.declareConcept(concept.describedQuality), DescriptionType.DESCRIBES));
			}
		}

		if (concept.describedProportionality !== null) {
			if (!type.contains(Type.QUALITY) && !type.contains(Type.ORDERING)) {
				error("Proportionality and discretizations can only be stated for qualities and orderings", concept,
					KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_PROPORTIONALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.describedProportionality)
			if (Kim.intersection(ttype, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
				error("Only continuously valued qualities can be the target of proportionality statements", concept,
					KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_PROPORTIONALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Tuples.create(Kim.INSTANCE.declareConcept(concept.describedProportionality),
						DescriptionType.INCREASES_WITH));
			}
		}

		if (concept.describedInverseProportionalityQuality !== null) {
			if (!type.contains(Type.QUALITY) && !type.contains(Type.ORDERING)) {
				error("Proportionality and discretizations can only be stated for qualities and orderings", concept,
					KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_INVERSE_PROPORTIONALITY_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.describedInverseProportionalityQuality)
			if (Kim.intersection(ttype, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
				error("Only continuously valued qualities can be the target of proportionality statements", concept,
					KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_INVERSE_PROPORTIONALITY_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Tuples.create(Kim.INSTANCE.declareConcept(concept.describedInverseProportionalityQuality),
						DescriptionType.DECREASES_WITH));
			}
		}

		if (concept.classifiesQuality !== null) {
			if (!type.contains(Type.ATTRIBUTE) && !type.contains(Type.REALM)) {
				error(
					"The 'classifies' clause can only be stated by attributes or realms. Use 'discretizes' for orderings.",
					concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__CLASSIFIES_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.classifiesQuality)
			if (!ttype.contains(Type.QUALITY)) {
				error("Only qualities can be classified by attributes", concept,
					KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__CLASSIFIES_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Tuples.create(Kim.INSTANCE.declareConcept(concept.classifiesQuality), DescriptionType.CLASSIFIES));
			}
		}

		if (concept.discretizesQuality !== null) {
			if (!type.contains(Type.ORDERING)) {
				error("The 'discretizes' clause can only be stated by attributes. Use 'classifies' for attributes.",
					concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DISCRETIZES_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.discretizesQuality)
			if (Kim.intersection(ttype, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
				error("Only continuously valued qualities can be discretized by orderings", concept,
					KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DISCRETIZES_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Tuples.create(Kim.INSTANCE.declareConcept(concept.discretizesQuality),
						DescriptionType.DISCRETIZES));
				}
			}

			if (concept.describedNonzeroQuality !== null) {
				if (!type.contains(Type.DENIABLE)) {
					error(
						"The 'marks' clause can only be stated by deniable attributes to indicate non-zero values of a quality.",
						concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_NONZERO_QUALITY)
					ok = false
				}
				var ttype = checkDeclaration(concept.describedNonzeroQuality)
				if (Kim.intersection(ttype, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
					error("Only continuously valued qualities can be flagged as 'marks' attributes", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_NONZERO_QUALITY)
					ok = false
				} else {
					ret.observablesDescribed.add(
						Tuples.create(Kim.INSTANCE.declareConcept(concept.describedNonzeroQuality),
							DescriptionType.MARKS));
				}
			}

			if (concept.roles.size > 0) {
				// TODO roles also use 'for targetObservable' and 'in' restrictedObservable
				if (!type.contains(Type.OBSERVABLE)) {
					error("only observables can have roles.", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__ROLES)
					ok = false
				} else {

					// get all the targets
					var i = 0;
					var targets = <IKimConcept>newArrayList
					for (t : concept.targetObservables) {
						var target = Kim.INSTANCE.declareConcept(t)
						if (!target.is(Type.COUNTABLE)) {
							error("Role targets must be countable concepts (subject, event or relationship)", concept,
								KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__TARGET_OBSERVABLES, i)
							ok = false
						} else {
							targets.add(target)
						}
						i++
					}
					if (targets.isEmpty) {
						targets.add(null)
					}

					// get all the restricting observables
					i = 0;
					var restricteds = <IKimConcept>newArrayList
					for (t : concept.restrictedObservables) {
						var robs = Kim.INSTANCE.declareConcept(t)
						if (!robs.is(Type.COUNTABLE)) {
							error(
								"Role target scenarios can only be countable concepts (subject, event or relationship)",
								concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__RESTRICTED_OBSERVABLES, i)
							ok = false
						} else {
							restricteds.add(robs)
						}
						i++
					}
					if (restricteds.isEmpty) {
						restricteds.add(null)
					}

					i = 0;

					for (r : concept.roles) {
						var role = Kim.INSTANCE.declareConcept(r)
						if (!role.is(Type.ROLE)) {
							error("This concept is not a role", concept,
								KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__ROLES, i)
							ok = false
						} else {

							for (target : targets) {
								for (restricted : restricteds) {
									ret.addRole(role, target, restricted)
								}
							}
						}
						i++
					}
				}
			}

			if (concept.conferredTraits.size > 0) {
				// process or event confers trait to participand subject (conferredTargets)	
				if (!type.contains(Type.PROCESS) && !type.contains(Type.EVENT)) {
					error("only processes and events can confer traits to their context subjects.", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__CONFERRED_TRAITS)
					ok = false
				} else {
					var i = 0
					for (decl : concept.conferredTraits) {
						var trait = Kim.INSTANCE.declareConcept(decl)
						if (!trait.is(Type.TRAIT)) {
							error("only traits can be conferred by processes or events", concept,
								KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__CONFERRED_TRAITS, i)
						} else {
							ret.traitsConferred.add(trait)
						}
						i++
					}
				}
			}

			if (concept.whole !== null) {
				// use concept.isConstituent to check part vs. constituent and concept.isPartOf to check 
				// for the use of 'of' which inverts the relationship.
				if (!type.contains(Type.SUBJECT) && !type.contains(Type.AGENT) &&
					!(type.contains(Type.CONFIGURATION) && concept.isConstitutes)) {
					error("only subjects can use mereological relationships", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__WHOLE)
					ok = false
				} else {
					var countable = Kim.INSTANCE.declareConcept(concept.whole)
					if (!type.contains(Type.CONFIGURATION) && !countable.is(Type.SUBJECT) &&
						!countable.is(Type.AGENT)) {
						error("only subjects can be parts of other subjects", concept,
							KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__WHOLE)
					} else {
						if (concept.isConstituent) {
							ret.constituentParticipants.add(countable)
						} else if (concept.isPartOf) {
							ret.partParticipants.add(countable)
						} else if (concept.isConstitutes) {
							ret.configurationParticipants.add(countable)
						} else {
							// TODO
							throw new IllegalArgumentException("inverse mereology still unsupported")
						}
					}
				}
			}

			if (concept.creates.size > 0) {
				// process or event creates countable in context
				if (!type.contains(Type.PROCESS) && !type.contains(Type.EVENT)) {
					error("only processes can use the 'creates' clause", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__CREATES)
					ok = false
				} else {
					var i = 0
					for (decl : concept.creates) {
						var countable = Kim.INSTANCE.declareConcept(decl)
						if (!countable.is(Type.COUNTABLE)) {
							error(
								"only countable types (subject, event, relationship) can be created by processes or events",
								concept, KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__CREATES, i)
						} else {
							ret.countablesCreated.add(countable)
						}
						i++
					}
				}
			}

			if (concept.traitTargets.size > 0) {
				// TODO applies to; can also restrict source and destination for relationships
				for (target : concept.traitTargets) {
				}
			}

			if (concept.domains.size > 0) {
				if (!type.contains(Type.RELATIONSHIP)) {
					error("only relationships can use the 'links clause", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__DOMAINS)
					ok = false
				} else {
					// TODO for relationships, moves in parallel with concept.ranges
				}
			}

			if (concept.inverse !== null) {
				if (!type.contains(Type.RELATIONSHIP)) {
					error("only relationships can use the 'inverse of' clause", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__INVERSE)
					ok = false
				} else {
					// TODO inverse of relationship	
				}
			}

			if (concept.qualitiesAffected.size > 0) {
				if (!type.contains(Type.PROCESS)) {
					error("only processes can use the 'affects' clause", concept,
						KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__QUALITIES_AFFECTED)
					ok = false
				} else {
					// TODO process affects quality; deliberative agents can affect states of subject types.
				}
			}

			for (restriction : concept.restrictions) {
				// TODO process restriction
			}

			if (concept.metadata !== null) {
				ret.metadata = new KimMetadata(concept.metadata)
			}

			if (ok) {

				ret.name = if (concept.isRoot)
					KimConceptStatement.ROOT_DOMAIN_NAME
				else
					concept.name

				/*
				 * proceed with concept descriptor; save template if any
				 */
				Kim.INSTANCE.setConceptDescriptor(namespace.name + ":" + concept.name,
					new ConceptDescriptor(namespace.name + ":" + concept.name, type, if(template) ret else null,
						concept.docstring))

				/*
				 * instantiate the rest of descriptor
				 */
				ret.macro = template
				ret.type.addAll(type)

				/*
				 * add to namespace if we're top-level
				 */
				if (parent === null) {

					/*
					 * check for raw quality declaration unless we are using core concepts
					 */
					if (type.contains(Type.QUALITY) && !concept.coreConcept &&
						!type.contains(Type.NOTHING) && /* !type.contains(Type.ABSTRACT) && */ Kim.
							intersection(ret.type, IKimConcept.QUALITY_TYPES).isEmpty()) {
						error("Cannot declare a raw quality without inheriting from a more specific type", concept,
							KdeclPackage.Literals.CONCEPT_STATEMENT_BODY__NAME)

					} else {
						namespace.getChildren().add(ret)
					}

				}

			}

			return ret
		}

		def notify(KimNotification notification, EObject object, EStructuralFeature cls, int index) {
			switch (notification.level) {
				case Level.SEVERE:
					error(notification.message, object, cls, index)
				case Level.WARNING:
					warning(notification.message, object, cls, index)
				case Level.INFO:
					info(notification.message, object, cls, index)
			}
		}
	}
	