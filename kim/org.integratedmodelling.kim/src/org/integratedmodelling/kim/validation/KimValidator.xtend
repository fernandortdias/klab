/*
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kim.validation

import java.util.EnumSet
import java.util.List
import java.util.logging.Level
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.integratedmodelling.kim.api.IKimConcept.Type
import org.integratedmodelling.kim.api.IKimModel
import org.integratedmodelling.kim.kdecl.Function
import org.integratedmodelling.kim.kim.ActionSpecification
import org.integratedmodelling.kim.kim.KimPackage
import org.integratedmodelling.kim.kim.Model
import org.integratedmodelling.kim.kim.ModelBodyStatement
import org.integratedmodelling.kim.kim.ModelStatement
import org.integratedmodelling.kim.kim.Namespace
import org.integratedmodelling.kim.kim.ObserveStatement
import org.integratedmodelling.kim.kim.ObserveStatementBody
import org.integratedmodelling.kim.kim.Statement
import org.integratedmodelling.kim.kim.Urn
import org.integratedmodelling.kim.model.ComputableResource
import org.integratedmodelling.kim.model.Kim
import org.integratedmodelling.kim.model.Kim.UrnDescriptor
import org.integratedmodelling.kim.model.KimAnnotation
import org.integratedmodelling.kim.model.KimBehavior
import org.integratedmodelling.kim.model.KimConcept
import org.integratedmodelling.kim.model.KimMetadata
import org.integratedmodelling.kim.model.KimModel
import org.integratedmodelling.kim.model.KimObservable
import org.integratedmodelling.kim.model.KimObserver
import org.integratedmodelling.kim.model.KimProject
import org.integratedmodelling.kim.model.KimServiceCall
import org.integratedmodelling.kim.model.SemanticType
import org.integratedmodelling.kim.utils.CamelCase

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class KimValidator extends AbstractKimValidator {

	public static val NONPRIVATE_SUBJECTIVE_MODEL = 'nonPrivateSubjectiveModel'
	public static val BAD_OBSERVABLE = 'badObservable'
	public static val BAD_OBSERVATION = 'badObservation'
	public static val INVALID_NONSEMANTIC_MODEL = 'invalidNonSemanticModel'
	public static val PROBLEMATIC_URN = 'problematicURN'
	public static val NO_NAMESPACE = 'noNamespace'
	public static val BAD_NAMESPACE_ID = 'badNamespaceId'

	static val nonSemanticModels = #{'number', 'text', 'boolean'}

	@Check
	def initializeRegisters(Model model) {
		var namespace = getNamespace(model)
		if (namespace !== null) {
			Kim.INSTANCE.initializeNamespaceRegisters(KimProject.getNamespaceId(namespace))
			Kim.INSTANCE.removeNamespace(namespace);
		}
	}

	@Check
	def checkNamespace(Namespace namespace) {
		// check domain
		if (!namespace.worldviewBound) {
			var ns = Kim.INSTANCE.getNamespace(namespace, true)
			var project = ns.project
			var expectedId = project.getNamespaceIdFor(namespace)
			if (expectedId === null) {
				warning(
					'This namespace is in a non-standard file location: name uniqueness and cross-referencing are not guaranteed',
					namespace, KimPackage.Literals.NAMESPACE__NAME)
			} else if (project !== null && !namespace.name.equals(expectedId)) {
				error("The name of this namespace does not match its file location: expecting '" + expectedId + "'",
					namespace, KimPackage.Literals.NAMESPACE__NAME, BAD_NAMESPACE_ID)
			}
		}
	}

	@Check
	def checkFunction(Function function) {
		// TODO check parameters
	}

	@Check
	def checkStatement(Statement statement) {

		if (statement.eContainer instanceof Model) {
			val namespace = (statement.eContainer as Model).namespace
			if (namespace === null) {
				error(
					'Statements can only be defined within a named namespace: please add a namespace instruction at the top of the file',
					statement, null, NO_NAMESPACE)
			}
		}
	}

	@Check(EXPENSIVE)
	def recheckUrn(Urn urn) {
		/*
		 * TODO provide a validation (EXPENSIVE) action to re-check all URNs from the server
		 */
	}

	@Check
	def checkUrn(Urn urn) {

		var EObject mo = urn.eContainer?.eContainer;
		var ModelStatement model = if(mo !== null && mo instanceof ModelStatement) mo as ModelStatement else null;

		val UrnDescriptor ud = if(model.body.urn !== null) Kim.INSTANCE.getUrnDescriptor(model.body.urn.name) else null;
		if (ud === null || ud.isDead || !ud.isAccessible) {
			if (ud !== null) {
				warning('URN ' + model.body.urn.name + (if (ud.isDead) {
					' is not functional at the moment'
				} else {
					' is not authorized for the current user'
				}) + (if (model === null) {
					''
				} else {
					': the containing model has been deactivated'
				}), urn, null, PROBLEMATIC_URN)
			} else {
				warning('URN is undefined' + (if (model === null) {
					''
				} else {
					': the containing model has been deactivated'
				}), urn, null, PROBLEMATIC_URN)
			}
			if (model !== null) {
				model.inactive = true;
			}
		}
	}

	@Check
	def checkModelDefinition(ModelBodyStatement model) {

		var ModelStatement statement;
		var List<KimObservable> observables = newArrayList
		var List<KimObservable> dependencies = newArrayList

		// we only get here if parsed correctly
		var ok = true

		if (model.eContainer instanceof ModelStatement) {
			statement = model.eContainer as ModelStatement;
			if (nonSemanticModels.contains(statement.model) && model.name === null) {
				error('Non-semantic models should have a lowercase ID as observable',
					KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, INVALID_NONSEMANTIC_MODEL)
				ok = false
			}
		}

		/*
		 * look-ahead the first observable to handle the special case where the 'observed as' is a concept and the first
		 * observable is a role.
		 */
		var firstObservable = if (model.observables.size() > 0) {
				Kim.INSTANCE.declareObservable(model.observables.get(0))
			} else {
				null;
			}

		var KimObservable interpretedRole = null

		if (firstObservable !== null && firstObservable.descriptor.is(Type.ROLE)) {

			if (model.concept === null) {
				error(
					"Models that specify a role to interpret their observable must declare a valid observable concept before 'as'",
					KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, 0, INVALID_NONSEMANTIC_MODEL)
				ok = false
			} else {
				interpretedRole = firstObservable
				firstObservable = Kim.INSTANCE.declareObservable(model.concept)

				if (firstObservable.descriptor.isUndefined) {
					error('Observable has undefined semantics', KimPackage.Literals.MODEL_BODY_STATEMENT__CONCEPT,
						BAD_OBSERVABLE)
					ok = false
				}
			// fall through to validation
			}
		}

		/*
		 * TODO check semantics:
		 * 	1. concordance URN/observable
		 *  2. private status if any observable is subjective
		 */
		for (var obsIdx = 0; obsIdx < model.observables.size(); obsIdx++) {

			// validated by context consistency left to reasoner
			var observable = if (obsIdx == 0 && firstObservable !== null)
					firstObservable
				else
					Kim.INSTANCE.declareObservable(model.observables.get(obsIdx))

			var definition = observable.descriptor
			if (definition.isUndefined && (obsIdx > 0 || interpretedRole === null)) {
				error('Observable has undefined semantics', KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES,
					obsIdx, BAD_OBSERVABLE)
				ok = false
			} else if (!definition.is(Type.OBSERVABLE) && !definition.is(Type.TRAIT) &&
				!definition.is(Type.CONFIGURATION)) {
				error('Models can only describe observables, configurations or traits',
					KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, BAD_OBSERVABLE)
				ok = false
			} else if (obsIdx == 0 && statement !== null && model.isInstantiator && !definition.is(Type.COUNTABLE)) {
				error(
					"The first observable in an instantiator model ('model each') must be countable: subject, event or relationship",
					KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, BAD_OBSERVABLE)
				ok = false
			} else if (statement !== null && definition.is(Type.SUBJECTIVE) && !statement.isPrivate) {
				error('A model producing subjective observables must be private',
					KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, BAD_OBSERVABLE)
				ok = false
			} else {
				// no error
				observables.add(observable)
			}
		}

		var i = 0
		for (cd : model.dependencies) {
			// context consistency left to reasoner
			var observable = Kim.INSTANCE.declareObservable(cd)
			var definition = observable.descriptor
			if (definition.isUndefined) {
				error('Dependency has undefined semantics', KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i,
					BAD_OBSERVABLE)
				ok = false
			} else if (!definition.is(Type.OBSERVABLE) && !definition.is(Type.TRAIT)) {
				error('Models can only consume observables or traits',
					KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, BAD_OBSERVABLE)
				ok = false
			} else {
				// no error
				dependencies.add(observable)
			}
			i++
		}

		// all the contextualization stuff
		for (contextualizer : model.contextualizers) {
			var List<KimConcept> classifiers = null

			// if any of the observables (not the dependencies) or the classifications/lookup tables
			// produce a subjective concept, model must be private
			if (contextualizer.classification !== null) {
				classifiers = newArrayList
				var type = EnumSet.noneOf(Type);
				var cchecked = false
				for (classifier : contextualizer.classification.classifiers) {
					var decl = Kim.INSTANCE.declareConcept(classifier.declaration)
					if (type == 0) {
						type = decl.getType
					} else {
						// TODO validate against both other classifiers and observable or 'by' type 
					}
					if (decl.is(Type.SUBJECTIVE) != 0 && !statement.isPrivate && !cchecked) {
						error('A model producing subjective observables must be private', classifier,
							KimPackage.Literals.CLASSIFIER__DECLARATION, BAD_OBSERVABLE)
						ok = false
						cchecked = true
					}
				}
			}
		}

		/*
		 * create model descriptor if top-level, no errors, for the generator to publish.
		 */
		if (ok && statement !== null) {

			/**
			 * Find the original namespace: if we don't have one, don't register
			 */
			var namespace = getNamespace(statement);

			if (namespace !== null) {

				// add to namespace
				var ns = Kim.INSTANCE.getNamespace(namespace, true)

				var descriptor = new KimModel(statement);
				descriptor.observables.addAll(observables)
				descriptor.dependencies.addAll(dependencies)
				descriptor.instantiator = model.isInstantiator
				if (interpretedRole !== null) {
					descriptor.interpreter = true
					descriptor.reinterpretingRole = interpretedRole.main
				}

				// data source - function or literal/remote URN
				if (model.urn !== null) {
					descriptor.resourceUrn = model.urn.name
				} else if (model.function !== null) {
					descriptor.resourceFunction = new KimServiceCall(model.function)
					for (notification : (descriptor.resourceFunction.get() as KimServiceCall).validateUsage(null)) {
						notify(notification, model.function, KimPackage.Literals.MODEL_BODY_STATEMENT__FUNCTION)
					}
				} else if (model.getBoolean() !== null) {
					descriptor.inlineValue = Boolean.parseBoolean(model.getBoolean())
				} else if (model.number !== null) {
					descriptor.inlineValue = Kim.INSTANCE.parseNumber(model.number)
				}

				// the rest
				descriptor.private = statement.isPrivate || ns.isPrivate
				descriptor.assessmentModel = statement.model.equals('assess')
				descriptor.learningModel = statement.model.equals('learn')
				descriptor.type = switch (statement.model) {
					case 'number': IKimModel.Type.NUMBER
					case 'text': IKimModel.Type.TEXT
					case 'boolean': IKimModel.Type.BOOLEAN
					default: IKimModel.Type.SEMANTIC
				}

				i = 0
				for (action : model.actions) {
					for (notification : (descriptor.behavior as KimBehavior).addAction(action, descriptor)) {
						notify(notification, model, KimPackage.Literals.MODEL_BODY_STATEMENT__ACTIONS, i)
					}
					i++
				}

				// all contextualizers
				for (contextualizer : model.contextualizers) {
					descriptor.contextualization.add(new ComputableResource(contextualizer))
				}

				if (model.name !== null) {
					descriptor.name = model.name
				} else if (descriptor.observables.size() > 0) {
					if (descriptor.observables.get(0).formalName !== null) {
						descriptor.name = observables.get(0).formalName
					} else {
						var name = if(model.instantiator) "instantiator" else "contextualizer";
						// TODO maybe if there are traits or roles we should add those too
						var st = new SemanticType(descriptor.observables.get(0).main.observable.name)
						descriptor.name = CamelCase.toLowerCase(st.name, '-') + "-" + name
					}
				}
				
				if (model.metadata !== null) {
					descriptor.metadata = new KimMetadata(model.metadata);
				}
				if (model.documentation !== null) {
//					descriptor.documentation = new KimMetadata(model.documentation);
				}

				/*
				 * Check all other models in namespace and if name is duplicated, add number starting from 1
				 */
				var n = 0
				for (object : ns.children) {
					if (object instanceof KimModel && (object as KimModel).name.startsWith(descriptor.name)) {
						n++;
					}
				}
				if (n > 0) {
					descriptor.name = descriptor.name + "-" + n;
				}

				i = 0
				for (annotation : statement.annotations) {
					var ann = new KimAnnotation(annotation, ns)
					descriptor.annotations.add(ann)
					for (notification : ann.validateUsage(descriptor)) {
						notify(notification, statement, KimPackage.Literals.MODEL_STATEMENT__ANNOTATIONS, i)
					}
					i++
				}

				// reset for outline
				model.name = descriptor.name

				ns.getChildren().add(descriptor)
			}

		}
	}

	def notify(KimNotification notification, EObject object, EStructuralFeature cls) {
		switch (notification.level) {
			case Level.SEVERE:
				error(notification.message, object, cls)
			case Level.WARNING:
				warning(notification.message, object, cls)
			case Level.INFO:
				info(notification.message, object, cls)
		}
	}

	@Check
	def checkActionSpecification(ActionSpecification action) {
	}

	@Check
	def checkObservation(ObserveStatement observation) {
		var obs = checkObservation(observation.body, null)
		if (obs !== null) {
			var ns = Kim.INSTANCE.getNamespace(observation, true)
			var i = 0
			for (annotation : observation.annotations) {
				val ann = new KimAnnotation(annotation, ns)
				obs.annotations.add(ann)
				for (notification : ann.validateUsage(obs)) {
					notify(notification, observation, KimPackage.Literals.OBSERVE_STATEMENT__ANNOTATIONS, i)
				}
				i++
			}
			ns.getChildren().add(obs)
		}
	}

	def KimObserver checkObservation(ObserveStatementBody observation, KimObserver parent) {

		var KimObserver ret = null
		var ok = true

		if (observation === null) {
			return null
		}
		var semantics = Kim.INSTANCE.declareObservable(observation.concept)
		if (semantics !== null) {
			if (semantics.descriptor.is(Type.SUBJECT) == 0 && semantics.descriptor.is(Type.EVENT) == 0) {
				error('Observations can only be created for subjects and events', observation,
					KimPackage.Literals.OBSERVE_STATEMENT_BODY__CONCEPT, BAD_OBSERVATION)
				ok = false
			} else {
				ret = new KimObserver(observation, semantics)
			}
		}

		for (obs : observation.observations) {
			var child = checkObservation(obs, ret)
			if (ret !== null) {
				ret.getChildren().add(child)
			} else {
				ok = false
			}
		}

		var i = 0;
		for (state : observation.states) {
			var stateSemantics = Kim.INSTANCE.declareObservable(state);
			if (stateSemantics.getValue() === null) {
				error("States declared in an observe statement must specify a value followed by 'as' and the semantics",
					observation, KimPackage.Literals.OBSERVE_STATEMENT_BODY__STATES, i)
				ok = false
			} else {
				ret.states.add(stateSemantics)
			}
			i++
		}

		i = 0;
		for (action : observation.actions) {
			for (notification : (ret.behavior as KimBehavior).addAction(action, ret)) {
				notify(notification, observation, KimPackage.Literals.OBSERVE_STATEMENT_BODY__ACTIONS, i)
				if (notification.level == Level.SEVERE) {
					ok = false
				}
			}
			i++
		}

		// TODO contextualization
		// TODO if event, ensure we have a time extent 
		return if(ok) ret else null
	}

	/*
	 * get the namespace object, assuming we are not one
	 */
	def static Namespace getNamespace(EObject statement) {

		if (statement instanceof Namespace) {
			return statement;
		} else if (statement instanceof Model) {
			return (statement as Model).namespace
		}
		var stat = statement
		while (stat !== null && !(stat instanceof Model)) {
			stat = stat.eContainer
		}
		return if(stat === null) null else getNamespace(stat)
	}

}
