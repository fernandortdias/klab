/*
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kim.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.integratedmodelling.kim.kdecl.Annotation;
import org.integratedmodelling.kim.kdecl.ApplicableTarget;
import org.integratedmodelling.kim.kdecl.Concept;
import org.integratedmodelling.kim.kdecl.ConceptDeclaration;
import org.integratedmodelling.kim.kdecl.ConceptReference;
import org.integratedmodelling.kim.kdecl.ConceptStatement;
import org.integratedmodelling.kim.kdecl.ConceptStatementBody;
import org.integratedmodelling.kim.kdecl.Currency;
import org.integratedmodelling.kim.kdecl.DocSelector;
import org.integratedmodelling.kim.kdecl.Function;
import org.integratedmodelling.kim.kdecl.IdentityRequirement;
import org.integratedmodelling.kim.kdecl.KdeclPackage;
import org.integratedmodelling.kim.kdecl.KeyValuePair;
import org.integratedmodelling.kim.kdecl.List;
import org.integratedmodelling.kim.kdecl.Literal;
import org.integratedmodelling.kim.kdecl.Metadata;
import org.integratedmodelling.kim.kdecl.ObservableSemantics;
import org.integratedmodelling.kim.kdecl.ParameterList;
import org.integratedmodelling.kim.kdecl.REL_OPERATOR;
import org.integratedmodelling.kim.kdecl.RestrictionDefinition;
import org.integratedmodelling.kim.kdecl.RestrictionStatement;
import org.integratedmodelling.kim.kdecl.Unit;
import org.integratedmodelling.kim.kdecl.UnitElement;
import org.integratedmodelling.kim.kdecl.UpperOntologyDefinition;
import org.integratedmodelling.kim.kdecl.Value;
import org.integratedmodelling.kim.kim.ActionSpecification;
import org.integratedmodelling.kim.kim.AttributeIdentifier;
import org.integratedmodelling.kim.kim.Classification;
import org.integratedmodelling.kim.kim.Classifier;
import org.integratedmodelling.kim.kim.ClassifierRHS;
import org.integratedmodelling.kim.kim.ComputableValue;
import org.integratedmodelling.kim.kim.Contextualization;
import org.integratedmodelling.kim.kim.FunctionOrID;
import org.integratedmodelling.kim.kim.Import;
import org.integratedmodelling.kim.kim.KimPackage;
import org.integratedmodelling.kim.kim.LookupTable;
import org.integratedmodelling.kim.kim.Model;
import org.integratedmodelling.kim.kim.ModelBodyStatement;
import org.integratedmodelling.kim.kim.ModelStatement;
import org.integratedmodelling.kim.kim.Namespace;
import org.integratedmodelling.kim.kim.ObserveStatement;
import org.integratedmodelling.kim.kim.ObserveStatementBody;
import org.integratedmodelling.kim.kim.OwlImport;
import org.integratedmodelling.kim.kim.Statement;
import org.integratedmodelling.kim.kim.Table;
import org.integratedmodelling.kim.kim.Urn;
import org.integratedmodelling.kim.kim.ValueAssignment;
import org.integratedmodelling.kim.services.KimGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractKimSemanticSequencer extends KnowledgeDeclarationSemanticSequencer {

	@Inject
	private KimGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KdeclPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KdeclPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case KdeclPackage.APPLICABLE_TARGET:
				sequence_ApplicableTarget(context, (ApplicableTarget) semanticObject); 
				return; 
			case KdeclPackage.CONCEPT:
				sequence_Concept(context, (Concept) semanticObject); 
				return; 
			case KdeclPackage.CONCEPT_DECLARATION:
				if (rule == grammarAccess.getConceptDeclarationRule()) {
					sequence_ConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFactorRule()) {
					sequence_ConceptDeclaration_Factor(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getTermRule()) {
					sequence_ConceptDeclaration_Factor_Term(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleConceptDeclarationRule()) {
					sequence_SimpleConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else break;
			case KdeclPackage.CONCEPT_REFERENCE:
				sequence_ConceptReference(context, (ConceptReference) semanticObject); 
				return; 
			case KdeclPackage.CONCEPT_STATEMENT:
				sequence_ConceptStatement(context, (ConceptStatement) semanticObject); 
				return; 
			case KdeclPackage.CONCEPT_STATEMENT_BODY:
				if (rule == grammarAccess.getChildConceptRule()) {
					sequence_ChildConcept_ConceptStatementBody(context, (ConceptStatementBody) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConceptStatementBodyRule()) {
					sequence_ConceptStatementBody(context, (ConceptStatementBody) semanticObject); 
					return; 
				}
				else break;
			case KdeclPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case KdeclPackage.DOC_SELECTOR:
				sequence_DocSelector(context, (DocSelector) semanticObject); 
				return; 
			case KdeclPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case KdeclPackage.IDENTITY_REQUIREMENT:
				sequence_IdentityRequirement(context, (IdentityRequirement) semanticObject); 
				return; 
			case KdeclPackage.KEY_VALUE_PAIR:
				sequence_KeyValuePair(context, (KeyValuePair) semanticObject); 
				return; 
			case KdeclPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case KdeclPackage.LITERAL:
				if (rule == grammarAccess.getLiteralOrIDRule()) {
					sequence_LiteralOrID(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralOrIdOrCommaRule()) {
					sequence_LiteralOrIdOrComma(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralRule()) {
					sequence_Literal(context, (Literal) semanticObject); 
					return; 
				}
				else break;
			case KdeclPackage.METADATA:
				if (rule == grammarAccess.getDocumentationRule()) {
					sequence_Documentation(context, (Metadata) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMetadataRule()) {
					sequence_Metadata(context, (Metadata) semanticObject); 
					return; 
				}
				else break;
			case KdeclPackage.NUMBER:
				sequence_Number(context, (org.integratedmodelling.kim.kdecl.Number) semanticObject); 
				return; 
			case KdeclPackage.OBSERVABLE_SEMANTICS:
				if (rule == grammarAccess.getNamedObservableSemanticsRule()) {
					sequence_NamedObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getObservableSemanticsRule()) {
					sequence_ObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleObservableSemanticsRule()) {
					sequence_SimpleObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else break;
			case KdeclPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case KdeclPackage.REL_OPERATOR:
				sequence_REL_OPERATOR(context, (REL_OPERATOR) semanticObject); 
				return; 
			case KdeclPackage.RESTRICTION_DEFINITION:
				sequence_RestrictionDefinition(context, (RestrictionDefinition) semanticObject); 
				return; 
			case KdeclPackage.RESTRICTION_STATEMENT:
				sequence_RestrictionStatement(context, (RestrictionStatement) semanticObject); 
				return; 
			case KdeclPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case KdeclPackage.UNIT_ELEMENT:
				sequence_UnitElement(context, (UnitElement) semanticObject); 
				return; 
			case KdeclPackage.UPPER_ONTOLOGY_DEFINITION:
				sequence_UpperOntologyDefinition(context, (UpperOntologyDefinition) semanticObject); 
				return; 
			case KdeclPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		else if (epackage == KimPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KimPackage.ACTION:
				sequence_Action(context, (org.integratedmodelling.kim.kim.Action) semanticObject); 
				return; 
			case KimPackage.ACTION_SPECIFICATION:
				sequence_ActionSpecification(context, (ActionSpecification) semanticObject); 
				return; 
			case KimPackage.ATTRIBUTE_IDENTIFIER:
				sequence_AttributeIdentifier(context, (AttributeIdentifier) semanticObject); 
				return; 
			case KimPackage.CLASSIFICATION:
				sequence_Classification(context, (Classification) semanticObject); 
				return; 
			case KimPackage.CLASSIFIER:
				sequence_Classifier(context, (Classifier) semanticObject); 
				return; 
			case KimPackage.CLASSIFIER_RHS:
				if (rule == grammarAccess.getClassifierRHSRule()) {
					sequence_ClassifierRHS(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTableClassifierRule()) {
					sequence_TableClassifier(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.COMPUTABLE_VALUE:
				if (rule == grammarAccess.getComputableValueRule()) {
					sequence_ComputableValue(context, (ComputableValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExecutableValueRule()) {
					sequence_ExecutableValue(context, (ComputableValue) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.CONTEXTUALIZATION:
				sequence_Contextualization(context, (Contextualization) semanticObject); 
				return; 
			case KimPackage.FUNCTION_OR_ID:
				sequence_FunctionOrID(context, (FunctionOrID) semanticObject); 
				return; 
			case KimPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case KimPackage.LOOKUP_TABLE:
				sequence_LookupTable(context, (LookupTable) semanticObject); 
				return; 
			case KimPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KimPackage.MODEL_BODY_STATEMENT:
				sequence_ModelBodyStatement(context, (ModelBodyStatement) semanticObject); 
				return; 
			case KimPackage.MODEL_STATEMENT:
				sequence_ModelStatement(context, (ModelStatement) semanticObject); 
				return; 
			case KimPackage.NAMESPACE:
				sequence_Namespace(context, (Namespace) semanticObject); 
				return; 
			case KimPackage.OBSERVE_STATEMENT:
				sequence_ObserveStatement(context, (ObserveStatement) semanticObject); 
				return; 
			case KimPackage.OBSERVE_STATEMENT_BODY:
				sequence_ObserveStatementBody(context, (ObserveStatementBody) semanticObject); 
				return; 
			case KimPackage.OWL_IMPORT:
				sequence_OwlImport(context, (OwlImport) semanticObject); 
				return; 
			case KimPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case KimPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case KimPackage.URN:
				sequence_Urn(context, (Urn) semanticObject); 
				return; 
			case KimPackage.VALUE_ASSIGNMENT:
				if (rule == grammarAccess.getValueAssignmentRule()) {
					sequence_ValueAssignment(context, (ValueAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueExecutionRule()) {
					sequence_ValueExecution(context, (ValueAssignment) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionSpecification returns ActionSpecification
	 *
	 * Constraint:
	 *     (
	 *         (integrated?='aggregated'? domain+=FunctionOrID domain+=FunctionOrID* (actions+=Action actions+=Action*)?) | 
	 *         (
	 *             trigger?='on' 
	 *             (
	 *                 initialization?='definition' | 
	 *                 resolution?='resolution' | 
	 *                 instantiation?='instantiation' | 
	 *                 termination?='termination' | 
	 *                 stateInitialization?='initialization' | 
	 *                 (event=ConceptDeclaration (anyContextEvent?='context' | (relatedEventContext?='related' eventContext=ConceptDeclaration))?)
	 *             ) 
	 *             parameters=List? 
	 *             (actions+=Action actions+=Action*)?
	 *         )
	 *     )
	 */
	protected void sequence_ActionSpecification(ISerializationContext context, ActionSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (
	 *         ((change?='change' | set?='set') assignments+=ValueAssignment assignments+=ValueAssignment* (conditionNegative?='unless'? condition=Value)?) | 
	 *         (integrate?='integrate' assignments+=ValueAssignment assignments+=ValueAssignment* (conditionNegative?='unless'? condition=Value)?) | 
	 *         (do?='do' executed+=ValueExecution executed+=ValueExecution* (conditionNegative?='unless'? condition=Value)?) | 
	 *         (move?='move' (where=Value | away?='away') condition=Value?)
	 *     )
	 */
	protected void sequence_Action(ISerializationContext context, org.integratedmodelling.kim.kim.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeIdentifier returns AttributeIdentifier
	 *
	 * Constraint:
	 *     (name=LOWERCASE_ID | name=UPPERCASE_ID | function=Function | expression=EXPR)
	 */
	protected void sequence_AttributeIdentifier(ISerializationContext context, AttributeIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classification returns Classification
	 *
	 * Constraint:
	 *     (classifiers+=Classifier classifiers+=Classifier*)
	 */
	protected void sequence_Classification(ISerializationContext context, Classification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierRHS returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         (toResolve+=ConceptDeclaration toResolve+=ConceptDeclaration*) | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_ClassifierRHS(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classifier returns Classifier
	 *
	 * Constraint:
	 *     (declaration=ConceptDeclaration (otherwise?='otherwise' | (negated?='unless'? classifier=ClassifierRHS))?)
	 */
	protected void sequence_Classifier(ISerializationContext context, Classifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComputableValue returns ComputableValue
	 *
	 * Constraint:
	 *     (
	 *         literal=LiteralOrIdOrComma | 
	 *         function=Function | 
	 *         (expr=EXPR (language=LOWERCASE_ID | language=UPPERCASE_ID | language=CAMELCASE_ID)?) | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         id=CAMELCASE_ID | 
	 *         list=List | 
	 *         null?='unknown'
	 *     )
	 */
	protected void sequence_ComputableValue(ISerializationContext context, ComputableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contextualization returns Contextualization
	 *
	 * Constraint:
	 *     (
	 *         value=ValueExecution | 
	 *         (discretization?='discretization'? classification=Classification) | 
	 *         lookupTable=LookupTable | 
	 *         (discretization?='discretized'? classificationProperty=PropertyId)
	 *     )
	 */
	protected void sequence_Contextualization(ISerializationContext context, Contextualization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExecutableValue returns ComputableValue
	 *
	 * Constraint:
	 *     (function=Function | (expr=EXPR (language=LOWERCASE_ID | language=UPPERCASE_ID | language=CAMELCASE_ID)?) | urn=UrnId)
	 */
	protected void sequence_ExecutableValue(ISerializationContext context, ComputableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionOrID returns FunctionOrID
	 *
	 * Constraint:
	 *     (function=Function | functionId=LOWERCASE_ID | functionId=NamespaceId)
	 */
	protected void sequence_FunctionOrID(ISerializationContext context, FunctionOrID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     ((imports=List | star?='*')? name=PathName)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupTable returns LookupTable
	 *
	 * Constraint:
	 *     ((args+=LOWERCASE_ID | args+='?') args+=LOWERCASE_ID? (args+='?'? args+=LOWERCASE_ID?)* (table=Table | ref=LOWERCASE_ID))
	 */
	protected void sequence_LookupTable(ISerializationContext context, LookupTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelBodyStatement returns ModelBodyStatement
	 *
	 * Constraint:
	 *     (
	 *         instantiator?='each'? 
	 *         (
	 *             urn=Urn | 
	 *             function=Function | 
	 *             number=Number | 
	 *             boolean='true' | 
	 *             boolean='false' | 
	 *             concept=SimpleObservableSemantics
	 *         )? 
	 *         (name=LOWERCASE_ID | (observables+=ObservableSemantics observables+=ObservableSemantics*)) 
	 *         (dependencies+=ObservableSemantics dependencies+=ObservableSemantics*)? 
	 *         (contextualizers+=Contextualization contextualizers+=Contextualization*)? 
	 *         actions+=ActionSpecification* 
	 *         metadata=Metadata? 
	 *         documentation=Documentation?
	 *     )
	 */
	protected void sequence_ModelBodyStatement(ISerializationContext context, ModelBodyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelStatement returns ModelStatement
	 *
	 * Constraint:
	 *     (annotations+=Annotation* (inactive?='void' | private?='private')* model=MODEL_TYPE body=ModelBodyStatement)
	 */
	protected void sequence_ModelStatement(ISerializationContext context, ModelStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     ((namespace=Namespace statements+=Statement+) | statements+=Statement+)?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Namespace returns Namespace
	 *
	 * Constraint:
	 *     (
	 *         annotations+=Annotation* 
	 *         (private?='private' | inactive?='void')* 
	 *         (scenario?='scenario' | worldviewBound?='worldview')? 
	 *         name=PathName 
	 *         docstring=STRING? 
	 *         (
	 *             (
	 *                 rootDomain?='root' | 
	 *                 domainConcept=Concept | 
	 *                 version=VersionNumber | 
	 *                 lookupNamespace+=PathName | 
	 *                 blacklistNamespace+=PathName | 
	 *                 weights=Metadata
	 *             )? 
	 *             (imported+=Import imported+=Import*)? 
	 *             (owlImports+=OwlImport owlImports+=OwlImport*)? 
	 *             (coverage+=Function coverage+=Function*)? 
	 *             (disjointNamespaces+=PathName disjointNamespaces+=PathName*)?
	 *         )+ 
	 *         metadata=Metadata? 
	 *         documentation=Metadata?
	 *     )
	 */
	protected void sequence_Namespace(ISerializationContext context, Namespace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObserveStatementBody returns ObserveStatementBody
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             concept=NamedObservableSemantics 
	 *             docstring=STRING? 
	 *             (parents+=PathName parents+=PathName*)? 
	 *             (
	 *                 (observations+=ObserveStatementBody | states+=ObservableSemantics) 
	 *                 states+=ObservableSemantics? 
	 *                 (observations+=ObserveStatementBody? states+=ObservableSemantics?)*
	 *             )? 
	 *             accessor=Function?
	 *         ) | 
	 *         actions+=ActionSpecification | 
	 *         metadata=Metadata | 
	 *         documentation=Metadata
	 *     )+
	 */
	protected void sequence_ObserveStatementBody(ISerializationContext context, ObserveStatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObserveStatement returns ObserveStatement
	 *
	 * Constraint:
	 *     (annotations+=Annotation* body=ObserveStatementBody)
	 */
	protected void sequence_ObserveStatement(ISerializationContext context, ObserveStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OwlImport returns OwlImport
	 *
	 * Constraint:
	 *     (name=STRING prefix=LOWERCASE_ID)
	 */
	protected void sequence_OwlImport(ISerializationContext context, OwlImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.OWL_IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.OWL_IMPORT__NAME));
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.OWL_IMPORT__PREFIX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.OWL_IMPORT__PREFIX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOwlImportAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOwlImportAccess().getPrefixLOWERCASE_IDTerminalRuleCall_1_1_0(), semanticObject.getPrefix());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         conceptStatement=ConceptStatement | 
	 *         modelStatement=ModelStatement | 
	 *         upperOntologyStatement=UpperOntologyDefinition | 
	 *         observeStatement=ObserveStatement
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableClassifier returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*' | 
	 *         anything?='#'
	 *     )
	 */
	protected void sequence_TableClassifier(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (((args+=LOWERCASE_ID args+=LOWERCASE_ID*) | (expr+=EXPR expr+=EXPR*)) elements+=TableClassifier elements+=TableClassifier*)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Urn returns Urn
	 *
	 * Constraint:
	 *     (name=UrnId | name=STRING | name=LocalFilePath)
	 */
	protected void sequence_Urn(ISerializationContext context, Urn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueAssignment returns ValueAssignment
	 *
	 * Constraint:
	 *     (target=LOWERCASE_ID? assignedValue=ComputableValue)
	 */
	protected void sequence_ValueAssignment(ISerializationContext context, ValueAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueExecution returns ValueAssignment
	 *
	 * Constraint:
	 *     (execValue=ExecutableValue target=LOWERCASE_ID?)
	 */
	protected void sequence_ValueExecution(ISerializationContext context, ValueAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
