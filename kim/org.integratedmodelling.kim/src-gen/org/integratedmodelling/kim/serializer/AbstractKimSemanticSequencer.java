/*
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kim.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.integratedmodelling.kim.kim.ActionSpecification;
import org.integratedmodelling.kim.kim.Annotation;
import org.integratedmodelling.kim.kim.ApplicableTarget;
import org.integratedmodelling.kim.kim.AttributeIdentifier;
import org.integratedmodelling.kim.kim.Classification;
import org.integratedmodelling.kim.kim.Classifier;
import org.integratedmodelling.kim.kim.ClassifierRHS;
import org.integratedmodelling.kim.kim.ComputableValue;
import org.integratedmodelling.kim.kim.Concept;
import org.integratedmodelling.kim.kim.ConceptDeclaration;
import org.integratedmodelling.kim.kim.ConceptReference;
import org.integratedmodelling.kim.kim.ConceptStatement;
import org.integratedmodelling.kim.kim.ConceptStatementBody;
import org.integratedmodelling.kim.kim.Currency;
import org.integratedmodelling.kim.kim.DefineStatement;
import org.integratedmodelling.kim.kim.DefinitionBody;
import org.integratedmodelling.kim.kim.Dependency;
import org.integratedmodelling.kim.kim.DocSelector;
import org.integratedmodelling.kim.kim.Function;
import org.integratedmodelling.kim.kim.FunctionOrID;
import org.integratedmodelling.kim.kim.HeaderRow;
import org.integratedmodelling.kim.kim.IdentityRequirement;
import org.integratedmodelling.kim.kim.Import;
import org.integratedmodelling.kim.kim.KeyValuePair;
import org.integratedmodelling.kim.kim.KimPackage;
import org.integratedmodelling.kim.kim.List;
import org.integratedmodelling.kim.kim.Literal;
import org.integratedmodelling.kim.kim.LookupTable;
import org.integratedmodelling.kim.kim.Map;
import org.integratedmodelling.kim.kim.MapEntry;
import org.integratedmodelling.kim.kim.Metadata;
import org.integratedmodelling.kim.kim.Model;
import org.integratedmodelling.kim.kim.ModelBodyStatement;
import org.integratedmodelling.kim.kim.ModelStatement;
import org.integratedmodelling.kim.kim.Namespace;
import org.integratedmodelling.kim.kim.ObservableSemantics;
import org.integratedmodelling.kim.kim.ObserveStatement;
import org.integratedmodelling.kim.kim.ObserveStatementBody;
import org.integratedmodelling.kim.kim.OwlImport;
import org.integratedmodelling.kim.kim.ParameterList;
import org.integratedmodelling.kim.kim.REL_OPERATOR;
import org.integratedmodelling.kim.kim.RestrictionDefinition;
import org.integratedmodelling.kim.kim.RestrictionStatement;
import org.integratedmodelling.kim.kim.Statement;
import org.integratedmodelling.kim.kim.Table;
import org.integratedmodelling.kim.kim.TableRow;
import org.integratedmodelling.kim.kim.Unit;
import org.integratedmodelling.kim.kim.UnitElement;
import org.integratedmodelling.kim.kim.UpperOntologyDefinition;
import org.integratedmodelling.kim.kim.Urn;
import org.integratedmodelling.kim.kim.Value;
import org.integratedmodelling.kim.kim.ValueAssignment;
import org.integratedmodelling.kim.services.KimGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractKimSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KimGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KimPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KimPackage.ACTION:
				sequence_Action(context, (org.integratedmodelling.kim.kim.Action) semanticObject); 
				return; 
			case KimPackage.ACTION_SPECIFICATION:
				sequence_ActionSpecification(context, (ActionSpecification) semanticObject); 
				return; 
			case KimPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case KimPackage.APPLICABLE_TARGET:
				sequence_ApplicableTarget(context, (ApplicableTarget) semanticObject); 
				return; 
			case KimPackage.ATTRIBUTE_IDENTIFIER:
				sequence_AttributeIdentifier(context, (AttributeIdentifier) semanticObject); 
				return; 
			case KimPackage.CLASSIFICATION:
				sequence_Classification(context, (Classification) semanticObject); 
				return; 
			case KimPackage.CLASSIFIER:
				sequence_Classifier(context, (Classifier) semanticObject); 
				return; 
			case KimPackage.CLASSIFIER_RHS:
				if (rule == grammarAccess.getClassifierRHSWithIdRule()) {
					sequence_ClassifierRHSWithId(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassifierRHSRule()) {
					sequence_ClassifierRHS(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTableClassifierRule()) {
					sequence_TableClassifier(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.COMPUTABLE_VALUE:
				if (rule == grammarAccess.getComputableValueRule()) {
					sequence_ComputableValue(context, (ComputableValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExecutableValueRule()) {
					sequence_ExecutableValue(context, (ComputableValue) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.CONCEPT:
				sequence_Concept(context, (Concept) semanticObject); 
				return; 
			case KimPackage.CONCEPT_DECLARATION:
				if (rule == grammarAccess.getConceptDeclarationRule()) {
					sequence_ConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFactorRule()) {
					sequence_ConceptDeclaration_Factor(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getTermRule()) {
					sequence_ConceptDeclaration_Factor_Term(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleConceptDeclarationRule()) {
					sequence_SimpleConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.CONCEPT_REFERENCE:
				sequence_ConceptReference(context, (ConceptReference) semanticObject); 
				return; 
			case KimPackage.CONCEPT_STATEMENT:
				sequence_ConceptStatement(context, (ConceptStatement) semanticObject); 
				return; 
			case KimPackage.CONCEPT_STATEMENT_BODY:
				if (rule == grammarAccess.getChildConceptRule()) {
					sequence_ChildConcept_ConceptStatementBody(context, (ConceptStatementBody) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConceptStatementBodyRule()) {
					sequence_ConceptStatementBody(context, (ConceptStatementBody) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case KimPackage.DEFINE_STATEMENT:
				sequence_DefineStatement(context, (DefineStatement) semanticObject); 
				return; 
			case KimPackage.DEFINITION_BODY:
				sequence_DefinitionBody(context, (DefinitionBody) semanticObject); 
				return; 
			case KimPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case KimPackage.DOC_SELECTOR:
				sequence_DocSelector(context, (DocSelector) semanticObject); 
				return; 
			case KimPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case KimPackage.FUNCTION_OR_ID:
				sequence_FunctionOrID(context, (FunctionOrID) semanticObject); 
				return; 
			case KimPackage.HEADER_ROW:
				sequence_HeaderRow(context, (HeaderRow) semanticObject); 
				return; 
			case KimPackage.IDENTITY_REQUIREMENT:
				sequence_IdentityRequirement(context, (IdentityRequirement) semanticObject); 
				return; 
			case KimPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case KimPackage.KEY_VALUE_PAIR:
				sequence_KeyValuePair(context, (KeyValuePair) semanticObject); 
				return; 
			case KimPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case KimPackage.LITERAL:
				if (rule == grammarAccess.getLiteralOrIDRule()) {
					sequence_LiteralOrID(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralOrIdOrCommaRule()) {
					sequence_LiteralOrIdOrComma(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralRule()) {
					sequence_Literal(context, (Literal) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.LOOKUP_TABLE:
				sequence_LookupTable(context, (LookupTable) semanticObject); 
				return; 
			case KimPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case KimPackage.MAP_ENTRY:
				sequence_MapEntry(context, (MapEntry) semanticObject); 
				return; 
			case KimPackage.METADATA:
				if (rule == grammarAccess.getDocumentationRule()) {
					sequence_Documentation(context, (Metadata) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMetadataRule()) {
					sequence_Metadata(context, (Metadata) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KimPackage.MODEL_BODY_STATEMENT:
				sequence_ModelBodyStatement(context, (ModelBodyStatement) semanticObject); 
				return; 
			case KimPackage.MODEL_STATEMENT:
				sequence_ModelStatement(context, (ModelStatement) semanticObject); 
				return; 
			case KimPackage.NAMESPACE:
				sequence_Namespace(context, (Namespace) semanticObject); 
				return; 
			case KimPackage.NUMBER:
				sequence_Number(context, (org.integratedmodelling.kim.kim.Number) semanticObject); 
				return; 
			case KimPackage.OBSERVABLE_SEMANTICS:
				if (rule == grammarAccess.getNamedObservableSemanticsRule()) {
					sequence_NamedObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getObservableSemanticsRule()) {
					sequence_ObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleObservableSemanticsRule()) {
					sequence_SimpleObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.OBSERVE_STATEMENT:
				sequence_ObserveStatement(context, (ObserveStatement) semanticObject); 
				return; 
			case KimPackage.OBSERVE_STATEMENT_BODY:
				sequence_ObserveStatementBody(context, (ObserveStatementBody) semanticObject); 
				return; 
			case KimPackage.OWL_IMPORT:
				sequence_OwlImport(context, (OwlImport) semanticObject); 
				return; 
			case KimPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case KimPackage.REL_OPERATOR:
				sequence_REL_OPERATOR(context, (REL_OPERATOR) semanticObject); 
				return; 
			case KimPackage.RESTRICTION_DEFINITION:
				sequence_RestrictionDefinition(context, (RestrictionDefinition) semanticObject); 
				return; 
			case KimPackage.RESTRICTION_STATEMENT:
				sequence_RestrictionStatement(context, (RestrictionStatement) semanticObject); 
				return; 
			case KimPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case KimPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case KimPackage.TABLE_ROW:
				sequence_TableRow(context, (TableRow) semanticObject); 
				return; 
			case KimPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case KimPackage.UNIT_ELEMENT:
				sequence_UnitElement(context, (UnitElement) semanticObject); 
				return; 
			case KimPackage.UPPER_ONTOLOGY_DEFINITION:
				sequence_UpperOntologyDefinition(context, (UpperOntologyDefinition) semanticObject); 
				return; 
			case KimPackage.URN:
				sequence_Urn(context, (Urn) semanticObject); 
				return; 
			case KimPackage.VALUE:
				if (rule == grammarAccess.getValueWithConceptRule()) {
					sequence_ValueWithConcept(context, (Value) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueWithIdAndConceptRule()) {
					sequence_ValueWithIdAndConcept(context, (Value) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueRule()) {
					sequence_Value(context, (Value) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.VALUE_ASSIGNMENT:
				if (rule == grammarAccess.getValueAssignmentRule()) {
					sequence_ValueAssignment(context, (ValueAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueExecutionRule()) {
					sequence_ValueExecution(context, (ValueAssignment) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionSpecification returns ActionSpecification
	 *
	 * Constraint:
	 *     (
	 *         (integrated?='aggregated'? over?='over' domain+=FunctionOrID domain+=FunctionOrID* (actions+=Action actions+=Action*)?) | 
	 *         (
	 *             (
	 *                 trigger?='on' 
	 *                 (
	 *                     initialization?='definition' | 
	 *                     resolution?='resolution' | 
	 *                     instantiation?='instantiation' | 
	 *                     termination?='termination' | 
	 *                     stateInitialization?='initialization' | 
	 *                     (event=ConceptDeclaration ((anyContextEvent?='context' | relatedEventContext?='related') eventContext=ConceptDeclaration)?)
	 *                 ) 
	 *                 parameters=List?
	 *             )? 
	 *             actions+=Action 
	 *             actions+=Action*
	 *         )
	 *     )
	 */
	protected void sequence_ActionSpecification(ISerializationContext context, ActionSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (
	 *         ((change?='change' | set?='set') assignments+=ValueAssignment assignments+=ValueAssignment* (conditionNegative?='unless'? condition=Value)?) | 
	 *         (integrate?='integrate' assignments+=ValueAssignment assignments+=ValueAssignment* (conditionNegative?='unless'? condition=Value)?) | 
	 *         ((do?='do' | do?='then' | do?='finally') executed+=ValueExecution executed+=ValueExecution* (conditionNegative?='unless'? condition=Value)?) | 
	 *         (move?='move' (where=Value | away?='away') condition=Value?)
	 *     )
	 */
	protected void sequence_Action(ISerializationContext context, org.integratedmodelling.kim.kim.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (name=ANNOTATION_ID parameters=ParameterList?)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ApplicableTarget returns ApplicableTarget
	 *
	 * Constraint:
	 *     (target=ConceptDeclaration (linkFrom=ConceptDeclaration linkTo=ConceptDeclaration)?)
	 */
	protected void sequence_ApplicableTarget(ISerializationContext context, ApplicableTarget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeIdentifier returns AttributeIdentifier
	 *
	 * Constraint:
	 *     (name=LOWERCASE_ID | name=UPPERCASE_ID | function=Function | expression=EXPR)
	 */
	protected void sequence_AttributeIdentifier(ISerializationContext context, AttributeIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChildConcept returns ConceptStatementBody
	 *
	 * Constraint:
	 *     (
	 *         <unknown> 
	 *         (
	 *             (
	 *                 annotations+=Annotation* 
	 *                 abstract?='abstract'? 
	 *                 (
	 *                     root?='root' | 
	 *                     (name=CAMELCASE_ID ((stringIdentifier=ID | stringIdentifier=STRING | intIdentifier=INT) (authority=UPPERCASE_ID | authority=UPPERCASE_PATH))?)
	 *                 ) 
	 *                 (
	 *                     (
	 *                         docstring=STRING | 
	 *                         definedAuthority=UPPERCASE_PATH | 
	 *                         upperConcept=Concept | 
	 *                         describedQuality=ConceptDeclaration | 
	 *                         describedProportionality=ConceptDeclaration | 
	 *                         describedInverseProportionalityQuality=ConceptDeclaration | 
	 *                         describedNonzeroQuality=ConceptDeclaration | 
	 *                         classifiesQuality=ConceptDeclaration | 
	 *                         discretizesQuality=ConceptDeclaration | 
	 *                         inverse=ConceptDeclaration | 
	 *                         restrictions+=RestrictionStatement | 
	 *                         metadata=Metadata
	 *                     )? 
	 *                     (traitTargets+=ApplicableTarget traitTargets+=ApplicableTarget*)? 
	 *                     (actuallyInheritedTraits+=ConceptDeclaration actuallyInheritedTraits+=ConceptDeclaration*)? 
	 *                     (creates+=ConceptDeclaration creates+=ConceptDeclaration*)? 
	 *                     (requirements+=IdentityRequirement requirements+=IdentityRequirement*)? 
	 *                     (qualitiesAffected+=ConceptDeclaration qualitiesAffected+=ConceptDeclaration*)? 
	 *                     (contextualizedTraits+=ObservableSemantics contextualizedTraits+=ObservableSemantics*)? 
	 *                     (conferredTraits+=ConceptDeclaration conferredTraits+=ConceptDeclaration*)? 
	 *                     (domains+=SimpleConceptDeclaration ranges+=SimpleConceptDeclaration)? 
	 *                     (disjoint?='disjoint'? children+=ChildConcept children+=ChildConcept*)? 
	 *                     (specific?='exposing' contextualizesTraits+=ConceptDeclaration contextualizesTraits+=ConceptDeclaration*)? 
	 *                     ((constituent?='constituent' | constitutes?='consists')? partOf?='of' whole=ConceptDeclaration)? 
	 *                     (
	 *                         roles+=ConceptDeclaration 
	 *                         roles+=ConceptDeclaration* 
	 *                         (targetObservables+=ConceptDeclaration targetObservables+=ConceptDeclaration*)? 
	 *                         restrictedObservables+=ConceptDeclaration 
	 *                         restrictedObservables+=ConceptDeclaration*
	 *                     )? 
	 *                     (
	 *                         (coreConcept?='core' | alias?='equals')? 
	 *                         (nothing?='nothing' | (parents+=ConceptDeclaration ((connectors+=',' | connectors+='or' | connectors+='and') parents+=ConceptDeclaration)*))
	 *                     )?
	 *                 )+
	 *             ) | 
	 *             (abstract?='abstract'? name=CAMELCASE_ID)
	 *         )
	 *     )
	 */
	protected void sequence_ChildConcept_ConceptStatementBody(ISerializationContext context, ConceptStatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classification returns Classification
	 *
	 * Constraint:
	 *     (classifiers+=Classifier classifiers+=Classifier*)
	 */
	protected void sequence_Classification(ISerializationContext context, Classification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierRHSWithId returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         id=LOWERCASE_ID | 
	 *         id=PropertyId | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_ClassifierRHSWithId(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierRHS returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         (toResolve+=ConceptDeclaration toResolve+=ConceptDeclaration*) | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_ClassifierRHS(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classifier returns Classifier
	 *
	 * Constraint:
	 *     (declaration=ConceptDeclaration (otherwise?='otherwise' | (negated?='unless'? classifier=ClassifierRHS))?)
	 */
	protected void sequence_Classifier(ISerializationContext context, Classifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComputableValue returns ComputableValue
	 *
	 * Constraint:
	 *     (
	 *         literal=LiteralOrIdOrComma | 
	 *         function=Function | 
	 *         (expr=EXPR (language=LOWERCASE_ID | language=UPPERCASE_ID | language=CAMELCASE_ID)?) | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         id=CAMELCASE_ID | 
	 *         list=List | 
	 *         null?='unknown'
	 *     )
	 */
	protected void sequence_ComputableValue(ISerializationContext context, ComputableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptDeclaration returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             inherency=SimpleConceptDeclaration | 
	 *             motivation=SimpleConceptDeclaration | 
	 *             compresent=SimpleConceptDeclaration | 
	 *             causant=SimpleConceptDeclaration | 
	 *             adjacent=SimpleConceptDeclaration | 
	 *             container=SimpleConceptDeclaration | 
	 *             contained=SimpleConceptDeclaration | 
	 *             caused=SimpleConceptDeclaration | 
	 *             during=SimpleConceptDeclaration | 
	 *             context=SimpleConceptDeclaration
	 *         )*
	 *     )
	 */
	protected void sequence_ConceptDeclaration(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Factor returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             inherency=SimpleConceptDeclaration | 
	 *             motivation=SimpleConceptDeclaration | 
	 *             compresent=SimpleConceptDeclaration | 
	 *             causant=SimpleConceptDeclaration | 
	 *             adjacent=SimpleConceptDeclaration | 
	 *             container=SimpleConceptDeclaration | 
	 *             contained=SimpleConceptDeclaration | 
	 *             caused=SimpleConceptDeclaration | 
	 *             during=SimpleConceptDeclaration | 
	 *             context=SimpleConceptDeclaration
	 *         )* 
	 *         ((operators+='and' | operators+='follows') operands+=Term)*
	 *     )
	 */
	protected void sequence_ConceptDeclaration_Factor(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ConceptDeclaration
	 *     Term returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             inherency=SimpleConceptDeclaration | 
	 *             motivation=SimpleConceptDeclaration | 
	 *             compresent=SimpleConceptDeclaration | 
	 *             causant=SimpleConceptDeclaration | 
	 *             adjacent=SimpleConceptDeclaration | 
	 *             container=SimpleConceptDeclaration | 
	 *             contained=SimpleConceptDeclaration | 
	 *             caused=SimpleConceptDeclaration | 
	 *             during=SimpleConceptDeclaration | 
	 *             context=SimpleConceptDeclaration
	 *         )* 
	 *         ((operators+='and' | operators+='follows') operands+=Term)* 
	 *         (operators+='or' operands+=Factor)*
	 *     )
	 */
	protected void sequence_ConceptDeclaration_Factor_Term(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptReference returns ConceptReference
	 *
	 * Constraint:
	 *     (
	 *         name=CAMELCASE_ID | 
	 *         name=NamespaceId | 
	 *         (
	 *             (templateType='${' | templateType='#{') 
	 *             (
	 *                 (name='context' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='inherent' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='compresent' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='adjacent' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='container' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='contained' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='purpose' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='causant' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='caused' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='cooccurrent' (type=CONCEPT_TYPE | extends=Concept))
	 *             ) 
	 *             template?='}'
	 *         )
	 *     )
	 */
	protected void sequence_ConceptReference(ISerializationContext context, ConceptReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptStatementBody returns ConceptStatementBody
	 *
	 * Constraint:
	 *     (
	 *         <unknown> 
	 *         annotations+=Annotation* 
	 *         abstract?='abstract'? 
	 *         (
	 *             root?='root' | 
	 *             (name=CAMELCASE_ID ((stringIdentifier=ID | stringIdentifier=STRING | intIdentifier=INT) (authority=UPPERCASE_ID | authority=UPPERCASE_PATH))?)
	 *         )
	 *     )
	 */
	protected void sequence_ConceptStatementBody(ISerializationContext context, ConceptStatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptStatement returns ConceptStatement
	 *
	 * Constraint:
	 *     (
	 *         annotations+=Annotation* 
	 *         (
	 *             (
	 *                 abstract?='abstract' | 
	 *                 deniable?='deniable' | 
	 *                 subjective?='subjective' | 
	 *                 agentSpecifier='deliberative' | 
	 *                 agentSpecifier='interactive' | 
	 *                 agentSpecifier='reactive'
	 *             )? 
	 *             (propertySpecifiers+=PROPERTY_TYPE propertySpecifiers+=PROPERTY_TYPE*)?
	 *         )+ 
	 *         concept=CONCEPT_TYPE 
	 *         body=ConceptStatementBody 
	 *         name=NamespaceId?
	 *     )
	 */
	protected void sequence_ConceptStatement(ISerializationContext context, ConceptStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns Concept
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (negated?='not' | negated?='no')? 
	 *             name=ConceptReference 
	 *             ((stringIdentifier=ID | stringIdentifier=STRING | intIdentifier=INT) (authority=UPPERCASE_ID | authority=UPPERCASE_PATH))?
	 *         ) | 
	 *         (presence?='presence' concept=SimpleConceptDeclaration) | 
	 *         (count?='count' concept=SimpleConceptDeclaration) | 
	 *         (distance?='distance' concept=SimpleConceptDeclaration) | 
	 *         (probability?='probability' concept=SimpleConceptDeclaration) | 
	 *         (assessment?='assessment' concept=SimpleConceptDeclaration) | 
	 *         (uncertainty?='uncertainty' concept=SimpleConceptDeclaration) | 
	 *         (magnitude?='magnitude' concept=SimpleConceptDeclaration) | 
	 *         (type?='type' concept=SimpleConceptDeclaration) | 
	 *         (observability?='observability' concept=SimpleConceptDeclaration) | 
	 *         (proportion?='proportion' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (percentage?='percentage' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (ratio?='ratio' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration) | 
	 *         (value?='value' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (occurrence?='occurrence' concept=SimpleConceptDeclaration) | 
	 *         declaration=Expression
	 *     )
	 */
	protected void sequence_Concept(ISerializationContext context, Concept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Currency returns Currency
	 *
	 * Constraint:
	 *     ((id=UPPERCASE_ID year=INT) | concept=CAMELCASE_ID | concept=NamespaceId)
	 */
	protected void sequence_Currency(ISerializationContext context, Currency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefineStatement returns DefineStatement
	 *
	 * Constraint:
	 *     ((annotations+=Annotation annotations+=Annotation*)? defineBody=DefinitionBody)
	 */
	protected void sequence_DefineStatement(ISerializationContext context, DefineStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionBody returns DefinitionBody
	 *
	 * Constraint:
	 *     (name=UPPERCASE_ID value=Value)
	 */
	protected void sequence_DefinitionBody(ISerializationContext context, DefinitionBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.DEFINITION_BODY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.DEFINITION_BODY__NAME));
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.DEFINITION_BODY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.DEFINITION_BODY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefinitionBodyAccess().getNameUPPERCASE_IDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDefinitionBodyAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     (modelReference=LOWERCASE_ID | modelReference=PathName | observable=ObservableSemantics)
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DocSelector returns DocSelector
	 *
	 * Constraint:
	 *     (id=PropertyId | definition?='definition' | initialization?='initialization' | termination?='termination' | transition?='transition')
	 */
	protected void sequence_DocSelector(ISerializationContext context, DocSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Documentation returns Metadata
	 *
	 * Constraint:
	 *     (selectors+=DocSelector values+=LiteralOrID)*
	 */
	protected void sequence_Documentation(ISerializationContext context, Metadata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExecutableValue returns ComputableValue
	 *
	 * Constraint:
	 *     (
	 *         (function=Function | (expr=EXPR (language=LOWERCASE_ID | language=UPPERCASE_ID | language=CAMELCASE_ID)?) | urn=UrnId) 
	 *         (conditionNegated?='unless'? condition=Value)?
	 *     )
	 */
	protected void sequence_ExecutableValue(ISerializationContext context, ComputableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionOrID returns FunctionOrID
	 *
	 * Constraint:
	 *     (function=Function | functionId=LOWERCASE_ID | functionId=NamespaceId)
	 */
	protected void sequence_FunctionOrID(ISerializationContext context, FunctionOrID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=PathName parameters=ParameterList?)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderRow returns HeaderRow
	 *
	 * Constraint:
	 *     ((elements+=LOWERCASE_ID | elements+=STRING) elements+=LOWERCASE_ID? (elements+=STRING? elements+=LOWERCASE_ID?)*)
	 */
	protected void sequence_HeaderRow(ISerializationContext context, HeaderRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IdentityRequirement returns IdentityRequirement
	 *
	 * Constraint:
	 *     ((identities+=ConceptDeclaration identities+=ConceptDeclaration*) | authority=UPPERCASE_ID | authority=UPPERCASE_PATH)
	 */
	protected void sequence_IdentityRequirement(ISerializationContext context, IdentityRequirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     ((imports=List | star?='*')? name=PathName)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyValuePair returns KeyValuePair
	 *
	 * Constraint:
	 *     ((name=PathName | name=LOWERCASE_ID) interactive?='?='? value=ValueWithIdAndConcept)
	 */
	protected void sequence_KeyValuePair(ISerializationContext context, KeyValuePair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     contents+=Value*
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralOrID returns Literal
	 *
	 * Constraint:
	 *     (number=Number | string=STRING | boolean='true' | boolean='false' | id=ID)
	 */
	protected void sequence_LiteralOrID(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralOrIdOrComma returns Literal
	 *
	 * Constraint:
	 *     (
	 *         (from=Number to=Number) | 
	 *         number=Number | 
	 *         string=STRING | 
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         id=ID | 
	 *         comma?=','
	 *     )
	 */
	protected void sequence_LiteralOrIdOrComma(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     ((from=Number to=Number) | number=Number | string=STRING | boolean='true' | boolean='false')
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupTable returns LookupTable
	 *
	 * Constraint:
	 *     table=Table?
	 */
	protected void sequence_LookupTable(ISerializationContext context, LookupTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntry returns MapEntry
	 *
	 * Constraint:
	 *     (classifier=ClassifierRHSWithId value=ValueWithIdAndConcept)
	 */
	protected void sequence_MapEntry(ISerializationContext context, MapEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.MAP_ENTRY__CLASSIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.MAP_ENTRY__CLASSIFIER));
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.MAP_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.MAP_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryAccess().getClassifierClassifierRHSWithIdParserRuleCall_0_0(), semanticObject.getClassifier());
		feeder.accept(grammarAccess.getMapEntryAccess().getValueValueWithIdAndConceptParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (entries+=MapEntry entries+=MapEntry*)?
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metadata returns Metadata
	 *
	 * Constraint:
	 *     ((ids+=PathName | ids+=LOWERCASE_ID | ids+=PropertyId | ids+=STRING) (values+=LiteralOrID | values+=Metadata | values+=List))*
	 */
	protected void sequence_Metadata(ISerializationContext context, Metadata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelBodyStatement returns ModelBodyStatement
	 *
	 * Constraint:
	 *     (
	 *         instantiator?='each'? 
	 *         (
	 *             (urns+=Urn urns+=Urn*) | 
	 *             function=Function | 
	 *             number=Number | 
	 *             boolean='true' | 
	 *             boolean='false' | 
	 *             concept=SimpleObservableSemantics
	 *         )? 
	 *         (name=LOWERCASE_ID | (observables+=ObservableSemantics observables+=ObservableSemantics*)) 
	 *         docstring=STRING? 
	 *         (dependencies+=Dependency dependencies+=Dependency*)? 
	 *         (contextualizers+=ValueExecution contextualizers+=ValueExecution*)? 
	 *         (discretization?='discretized'? (classification=Classification | classificationProperty=PropertyId))? 
	 *         (
	 *             (
	 *                 (lookupTableArgs+=LOWERCASE_ID | lookupTableArgs+='?' | lookupTableArgs+='*') 
	 *                 (lookupTableArgs+=LOWERCASE_ID | lookupTableArgs+='?' | lookupTableArgs+='*')*
	 *             )? 
	 *             (lookupTable=Table | lookupTableId=UPPERCASE_ID)
	 *         )? 
	 *         actions+=ActionSpecification* 
	 *         metadata=Metadata?
	 *     )
	 */
	protected void sequence_ModelBodyStatement(ISerializationContext context, ModelBodyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelStatement returns ModelStatement
	 *
	 * Constraint:
	 *     ((annotations+=Annotation annotations+=Annotation*)? (inactive?='void' | private?='private')* model=MODEL_TYPE body=ModelBodyStatement)
	 */
	protected void sequence_ModelStatement(ISerializationContext context, ModelStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (observable=ObservableSemantics | (namespace=Namespace statements+=Statement+) | statements+=Statement+)?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (declaration=ConceptDeclaration (name=LOWERCASE_ID | name=LOWERCASE_DASHID | name=STRING))
	 */
	protected void sequence_NamedObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Namespace returns Namespace
	 *
	 * Constraint:
	 *     (
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (private?='private' | inactive?='void')* 
	 *         (scenario?='scenario' | worldviewBound?='worldview')? 
	 *         name=PathName 
	 *         docstring=STRING? 
	 *         (
	 *             (
	 *                 rootDomain?='root' | 
	 *                 domainConcept=Concept | 
	 *                 version=VersionNumber | 
	 *                 lookupNamespace+=PathName | 
	 *                 blacklistNamespace+=PathName | 
	 *                 weights=Metadata
	 *             )? 
	 *             (imported+=Import imported+=Import*)? 
	 *             (owlImports+=OwlImport owlImports+=OwlImport*)? 
	 *             (coverage+=Function coverage+=Function*)? 
	 *             (disjointNamespaces+=PathName disjointNamespaces+=PathName*)?
	 *         )+ 
	 *         parameters=Metadata? 
	 *         metadata=Metadata?
	 *     )
	 */
	protected void sequence_Namespace(ISerializationContext context, Namespace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (negative?='-'? real=INT (decimal?='.' decimalPart=INT)? ((exponential?='e' | exponential?='E') expNegative?='-'? exp=INT)?)
	 */
	protected void sequence_Number(ISerializationContext context, org.integratedmodelling.kim.kim.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         value=Value? 
	 *         generic?='any'? 
	 *         declaration=ConceptDeclaration 
	 *         (
	 *             (
	 *                 by=Concept | 
	 *                 downTo=Concept | 
	 *                 role=Concept | 
	 *                 accordingTo=PropertyId | 
	 *                 unit=Unit | 
	 *                 currency=Currency | 
	 *                 unit=Unit | 
	 *                 optional?='optional' | 
	 *                 name=LOWERCASE_ID | 
	 *                 name=STRING
	 *             )? 
	 *             (from=Number to=Number)?
	 *         )+
	 *     )
	 */
	protected void sequence_ObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObserveStatementBody returns ObserveStatementBody
	 *
	 * Constraint:
	 *     (
	 *         (accessor=Function | metadata=Metadata)? 
	 *         (
	 *             urn=Urn? 
	 *             concept=NamedObservableSemantics 
	 *             docstring=STRING? 
	 *             (parents+=PathName parents+=PathName*)? 
	 *             ((states+=ObservableSemantics states+=ObservableSemantics*) | (observations+=ObserveStatementBody observations+=ObserveStatementBody*))* 
	 *             actions+=ActionSpecification*
	 *         )?
	 *     )+
	 */
	protected void sequence_ObserveStatementBody(ISerializationContext context, ObserveStatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObserveStatement returns ObserveStatement
	 *
	 * Constraint:
	 *     ((annotations+=Annotation annotations+=Annotation*)? body=ObserveStatementBody)
	 */
	protected void sequence_ObserveStatement(ISerializationContext context, ObserveStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OwlImport returns OwlImport
	 *
	 * Constraint:
	 *     (name=STRING prefix=LOWERCASE_ID)
	 */
	protected void sequence_OwlImport(ISerializationContext context, OwlImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.OWL_IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.OWL_IMPORT__NAME));
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.OWL_IMPORT__PREFIX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.OWL_IMPORT__PREFIX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOwlImportAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOwlImportAccess().getPrefixLOWERCASE_IDTerminalRuleCall_1_1_0(), semanticObject.getPrefix());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     ((pairs+=KeyValuePair pairs+=KeyValuePair*) | singleValue=ValueWithIdAndConcept)
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     REL_OPERATOR returns REL_OPERATOR
	 *
	 * Constraint:
	 *     (
	 *         gt?='>' | 
	 *         lt?='<' | 
	 *         eq?='=' | 
	 *         ne?='!=' | 
	 *         le?='<=' | 
	 *         ge?='>='
	 *     )
	 */
	protected void sequence_REL_OPERATOR(ISerializationContext context, REL_OPERATOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RestrictionDefinition returns RestrictionDefinition
	 *
	 * Constraint:
	 *     (
	 *         (only?='only' | none?='no' | ((exactly?='exactly' | atLeast?='least' | atMost?='most') howmany=INT))? 
	 *         (source=ConceptDeclaration | dataType=DataType) 
	 *         traitType=ConceptDeclaration? 
	 *         subject=ConceptDeclaration?
	 *     )
	 */
	protected void sequence_RestrictionDefinition(ISerializationContext context, RestrictionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RestrictionStatement returns RestrictionStatement
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (relType='uses' | relType='has' | relType='contains' | relType='implies') 
	 *             definitions+=RestrictionDefinition 
	 *             definitions+=RestrictionDefinition*
	 *         ) | 
	 *         (
	 *             (authorities+=UPPERCASE_ID | authorities+=UPPERCASE_PATH) 
	 *             authorities+=UPPERCASE_ID? 
	 *             (authorities+=UPPERCASE_PATH? authorities+=UPPERCASE_ID?)*
	 *         ) | 
	 *         (value=Literal literal?='for' (subject=CAMELCASE_ID | subject=NamespaceId))
	 *     )
	 */
	protected void sequence_RestrictionStatement(ISerializationContext context, RestrictionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleConceptDeclaration returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (name=STRING? main+=Concept+)
	 */
	protected void sequence_SimpleConceptDeclaration(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         declaration=ConceptDeclaration 
	 *         (
	 *             (
	 *                 by=Concept | 
	 *                 downTo=Concept | 
	 *                 accordingTo=PropertyId | 
	 *                 unit=Unit | 
	 *                 currency=Currency | 
	 *                 unit=Unit | 
	 *                 name=LOWERCASE_ID | 
	 *                 name=STRING
	 *             )? 
	 *             (from=Number to=Number)?
	 *         )+
	 *     )
	 */
	protected void sequence_SimpleObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         conceptStatement=ConceptStatement | 
	 *         modelStatement=ModelStatement | 
	 *         upperOntologyStatement=UpperOntologyDefinition | 
	 *         defineStatement=DefineStatement | 
	 *         observeStatement=ObserveStatement
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableClassifier returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         expr=EXPR | 
	 *         nodata='unknown' | 
	 *         star?='*' | 
	 *         anything?='#'
	 *     )
	 */
	protected void sequence_TableClassifier(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (elements+=TableClassifier elements+=TableClassifier*)
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (headers=HeaderRow? rows+=TableRow rows+=TableRow*)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns UnitElement
	 *
	 * Constraint:
	 *     (id=CAMELCASE_ID | id=LOWERCASE_ID | id=UPPERCASE_ID | num=Number | unit=Unit)
	 */
	protected void sequence_UnitElement(ISerializationContext context, UnitElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (root=UnitElement? (connectors+=UnitOp units+=UnitElement)*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UpperOntologyDefinition returns UpperOntologyDefinition
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 ((agentSpecifier='deliberative' | agentSpecifier='interactive' | agentSpecifier='reactive') concept='agent') | 
	 *                 (propertySpecifiers+=PROPERTY_TYPE propertySpecifiers+=PROPERTY_TYPE* concept='relationship')
	 *             )? 
	 *             (coreconcept=NamespaceId | coreconcept=PropertyId)
	 *         ) | 
	 *         (operand=OPERATOR_TARGET (property=PropertyId | property=NamespaceId))
	 *     )
	 */
	protected void sequence_UpperOntologyDefinition(ISerializationContext context, UpperOntologyDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Urn returns Urn
	 *
	 * Constraint:
	 *     (name=UrnId | name=STRING | name=LocalFilePath)
	 */
	protected void sequence_Urn(ISerializationContext context, Urn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueAssignment returns ValueAssignment
	 *
	 * Constraint:
	 *     (target=LOWERCASE_ID? assignedValue=ComputableValue)
	 */
	protected void sequence_ValueAssignment(ISerializationContext context, ValueAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueExecution returns ValueAssignment
	 *
	 * Constraint:
	 *     (execValue=ExecutableValue target=LOWERCASE_ID?)
	 */
	protected void sequence_ValueExecution(ISerializationContext context, ValueAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueWithConcept returns Value
	 *
	 * Constraint:
	 *     (
	 *         concept=ConceptDeclaration | 
	 *         literal=Literal | 
	 *         expr=EXPR | 
	 *         list=List | 
	 *         table=LookupTable | 
	 *         map=Map | 
	 *         null?='unknown'
	 *     )
	 */
	protected void sequence_ValueWithConcept(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueWithIdAndConcept returns Value
	 *
	 * Constraint:
	 *     (
	 *         concept=ConceptDeclaration | 
	 *         function=Function | 
	 *         literal=Literal | 
	 *         expr=EXPR | 
	 *         id=PathName | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         id=CAMELCASE_ID | 
	 *         list=List | 
	 *         table=LookupTable | 
	 *         map=Map | 
	 *         null?='unknown'
	 *     )
	 */
	protected void sequence_ValueWithIdAndConcept(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (
	 *         literal=LiteralOrIdOrComma | 
	 *         function=Function | 
	 *         expr=EXPR | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         id=CAMELCASE_ID | 
	 *         list=List | 
	 *         table=LookupTable | 
	 *         map=Map | 
	 *         null?='unknown'
	 *     )
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
