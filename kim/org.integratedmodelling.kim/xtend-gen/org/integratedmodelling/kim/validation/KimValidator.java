/**
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kim.validation;

import com.google.common.base.Objects;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.integratedmodelling.kim.api.IComputableResource;
import org.integratedmodelling.kim.api.IKimBehavior;
import org.integratedmodelling.kim.api.IKimConcept;
import org.integratedmodelling.kim.api.IKimModel;
import org.integratedmodelling.kim.api.IKimProject;
import org.integratedmodelling.kim.api.IKimScope;
import org.integratedmodelling.kim.api.IServiceCall;
import org.integratedmodelling.kim.kdecl.Annotation;
import org.integratedmodelling.kim.kdecl.Documentation;
import org.integratedmodelling.kim.kdecl.Function;
import org.integratedmodelling.kim.kdecl.Metadata;
import org.integratedmodelling.kim.kdecl.ObservableSemantics;
import org.integratedmodelling.kim.kim.ActionSpecification;
import org.integratedmodelling.kim.kim.Classification;
import org.integratedmodelling.kim.kim.Classifier;
import org.integratedmodelling.kim.kim.Contextualization;
import org.integratedmodelling.kim.kim.KimPackage;
import org.integratedmodelling.kim.kim.Model;
import org.integratedmodelling.kim.kim.ModelBodyStatement;
import org.integratedmodelling.kim.kim.ModelStatement;
import org.integratedmodelling.kim.kim.Namespace;
import org.integratedmodelling.kim.kim.ObserveStatement;
import org.integratedmodelling.kim.kim.ObserveStatementBody;
import org.integratedmodelling.kim.kim.Statement;
import org.integratedmodelling.kim.kim.Urn;
import org.integratedmodelling.kim.model.ComputableResource;
import org.integratedmodelling.kim.model.Kim;
import org.integratedmodelling.kim.model.KimAnnotation;
import org.integratedmodelling.kim.model.KimBehavior;
import org.integratedmodelling.kim.model.KimConcept;
import org.integratedmodelling.kim.model.KimMetadata;
import org.integratedmodelling.kim.model.KimModel;
import org.integratedmodelling.kim.model.KimNamespace;
import org.integratedmodelling.kim.model.KimObservable;
import org.integratedmodelling.kim.model.KimObserver;
import org.integratedmodelling.kim.model.KimProject;
import org.integratedmodelling.kim.model.KimServiceCall;
import org.integratedmodelling.kim.model.SemanticType;
import org.integratedmodelling.kim.utils.CamelCase;
import org.integratedmodelling.kim.validation.AbstractKimValidator;
import org.integratedmodelling.kim.validation.KimNotification;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class KimValidator extends AbstractKimValidator {
  public final static String NONPRIVATE_SUBJECTIVE_MODEL = "nonPrivateSubjectiveModel";
  
  public final static String BAD_OBSERVABLE = "badObservable";
  
  public final static String BAD_OBSERVATION = "badObservation";
  
  public final static String INVALID_NONSEMANTIC_MODEL = "invalidNonSemanticModel";
  
  public final static String PROBLEMATIC_URN = "problematicURN";
  
  public final static String NO_NAMESPACE = "noNamespace";
  
  public final static String BAD_NAMESPACE_ID = "badNamespaceId";
  
  private final static Set<String> nonSemanticModels = Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet("number", "text", "boolean"));
  
  @Check
  public void initializeRegisters(final Model model) {
    Namespace namespace = KimValidator.getNamespace(model);
    if ((namespace != null)) {
      Kim.INSTANCE.initializeNamespaceRegisters(KimProject.getNamespaceId(namespace));
      Kim.INSTANCE.removeNamespace(namespace);
    }
  }
  
  @Check
  public void checkNamespace(final Namespace namespace) {
    boolean _isWorldviewBound = namespace.isWorldviewBound();
    boolean _not = (!_isWorldviewBound);
    if (_not) {
      KimNamespace ns = Kim.INSTANCE.getNamespace(namespace, true);
      IKimProject project = ns.getProject();
      String expectedId = project.getNamespaceIdFor(namespace);
      if ((expectedId == null)) {
        this.warning(
          "This namespace is in a non-standard file location: name uniqueness and cross-referencing are not guaranteed", namespace, KimPackage.Literals.NAMESPACE__NAME);
      } else {
        if (((project != null) && (!namespace.getName().equals(expectedId)))) {
          this.error((("The name of this namespace does not match its file location: expecting \'" + expectedId) + "\'"), namespace, KimPackage.Literals.NAMESPACE__NAME, KimValidator.BAD_NAMESPACE_ID);
        }
      }
    }
  }
  
  @Check
  public Object checkFunction(final Function function) {
    return null;
  }
  
  @Check
  public void checkStatement(final Statement statement) {
    EObject _eContainer = statement.eContainer();
    if ((_eContainer instanceof Model)) {
      EObject _eContainer_1 = statement.eContainer();
      final Namespace namespace = ((Model) _eContainer_1).getNamespace();
      if ((namespace == null)) {
        this.error(
          "Statements can only be defined within a named namespace: please add a namespace instruction at the top of the file", statement, null, KimValidator.NO_NAMESPACE);
      }
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public Object recheckUrn(final Urn urn) {
    return null;
  }
  
  @Check
  public void checkUrn(final Urn urn) {
    EObject _eContainer = urn.eContainer();
    EObject _eContainer_1 = null;
    if (_eContainer!=null) {
      _eContainer_1=_eContainer.eContainer();
    }
    EObject mo = _eContainer_1;
    ModelStatement _xifexpression = null;
    if (((mo != null) && (mo instanceof ModelStatement))) {
      _xifexpression = ((ModelStatement) mo);
    } else {
      _xifexpression = null;
    }
    ModelStatement model = _xifexpression;
    Kim.UrnDescriptor _xifexpression_1 = null;
    Urn _urn = model.getBody().getUrn();
    boolean _tripleNotEquals = (_urn != null);
    if (_tripleNotEquals) {
      _xifexpression_1 = Kim.INSTANCE.getUrnDescriptor(model.getBody().getUrn().getName());
    } else {
      _xifexpression_1 = null;
    }
    final Kim.UrnDescriptor ud = _xifexpression_1;
    if ((((ud == null) || ud.isDead()) || (!ud.isAccessible()))) {
      if ((ud != null)) {
        String _name = model.getBody().getUrn().getName();
        String _plus = ("URN " + _name);
        String _xifexpression_2 = null;
        boolean _isDead = ud.isDead();
        if (_isDead) {
          _xifexpression_2 = " is not functional at the moment";
        } else {
          _xifexpression_2 = " is not authorized for the current user";
        }
        String _plus_1 = (_plus + _xifexpression_2);
        String _xifexpression_3 = null;
        if ((model == null)) {
          _xifexpression_3 = "";
        } else {
          _xifexpression_3 = ": the containing model has been deactivated";
        }
        String _plus_2 = (_plus_1 + _xifexpression_3);
        this.warning(_plus_2, urn, null, KimValidator.PROBLEMATIC_URN);
      } else {
        String _xifexpression_4 = null;
        if ((model == null)) {
          _xifexpression_4 = "";
        } else {
          _xifexpression_4 = ": the containing model has been deactivated";
        }
        String _plus_3 = ("URN is undefined" + _xifexpression_4);
        this.warning(_plus_3, urn, null, KimValidator.PROBLEMATIC_URN);
      }
      if ((model != null)) {
        model.setInactive(true);
      }
    }
  }
  
  @Check
  public boolean checkModelDefinition(final ModelBodyStatement model) {
    boolean _xblockexpression = false;
    {
      ModelStatement statement = null;
      List<KimObservable> observables = CollectionLiterals.<KimObservable>newArrayList();
      List<KimObservable> dependencies = CollectionLiterals.<KimObservable>newArrayList();
      boolean ok = true;
      EObject _eContainer = model.eContainer();
      if ((_eContainer instanceof ModelStatement)) {
        EObject _eContainer_1 = model.eContainer();
        statement = ((ModelStatement) _eContainer_1);
        if ((KimValidator.nonSemanticModels.contains(statement.getModel()) && (model.getName() == null))) {
          this.error("Non-semantic models should have a lowercase ID as observable", 
            KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, KimValidator.INVALID_NONSEMANTIC_MODEL);
          ok = false;
        }
      }
      KimObservable _xifexpression = null;
      int _size = model.getObservables().size();
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        _xifexpression = Kim.INSTANCE.declareObservable(model.getObservables().get(0));
      } else {
        _xifexpression = null;
      }
      KimObservable firstObservable = _xifexpression;
      KimObservable interpretedRole = null;
      if (((firstObservable != null) && firstObservable.getDescriptor().is(IKimConcept.Type.ROLE))) {
        ObservableSemantics _concept = model.getConcept();
        boolean _tripleEquals = (_concept == null);
        if (_tripleEquals) {
          this.error(
            "Models that specify a role to interpret their observable must declare a valid observable concept before \'as\'", 
            KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, 0, KimValidator.INVALID_NONSEMANTIC_MODEL);
          ok = false;
        } else {
          interpretedRole = firstObservable;
          firstObservable = Kim.INSTANCE.declareObservable(model.getConcept());
          boolean _isUndefined = firstObservable.getDescriptor().isUndefined();
          if (_isUndefined) {
            this.error("Observable has undefined semantics", KimPackage.Literals.MODEL_BODY_STATEMENT__CONCEPT, 
              KimValidator.BAD_OBSERVABLE);
            ok = false;
          }
        }
      }
      for (int obsIdx = 0; (obsIdx < model.getObservables().size()); obsIdx++) {
        {
          KimObservable _xifexpression_1 = null;
          if (((obsIdx == 0) && (firstObservable != null))) {
            _xifexpression_1 = firstObservable;
          } else {
            _xifexpression_1 = Kim.INSTANCE.declareObservable(model.getObservables().get(obsIdx));
          }
          KimObservable observable = _xifexpression_1;
          Kim.ConceptDescriptor definition = observable.getDescriptor();
          if ((definition.isUndefined() && ((obsIdx > 0) || (interpretedRole == null)))) {
            this.error("Observable has undefined semantics", KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.BAD_OBSERVABLE);
            ok = false;
          } else {
            if ((((!definition.is(IKimConcept.Type.OBSERVABLE)) && (!definition.is(IKimConcept.Type.TRAIT))) && 
              (!definition.is(IKimConcept.Type.CONFIGURATION)))) {
              this.error("Models can only describe observables, configurations or traits", 
                KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.BAD_OBSERVABLE);
              ok = false;
            } else {
              if (((((obsIdx == 0) && (statement != null)) && model.isInstantiator()) && (!definition.is(IKimConcept.Type.COUNTABLE)))) {
                this.error(
                  "The first observable in an instantiator model (\'model each\') must be countable: subject, event or relationship", 
                  KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.BAD_OBSERVABLE);
                ok = false;
              } else {
                if ((((statement != null) && definition.is(IKimConcept.Type.SUBJECTIVE)) && (!statement.isPrivate()))) {
                  this.error("A model producing subjective observables must be private", 
                    KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.BAD_OBSERVABLE);
                  ok = false;
                } else {
                  observables.add(observable);
                }
              }
            }
          }
        }
      }
      int i = 0;
      EList<ObservableSemantics> _dependencies = model.getDependencies();
      for (final ObservableSemantics cd : _dependencies) {
        {
          KimObservable observable = Kim.INSTANCE.declareObservable(cd);
          Kim.ConceptDescriptor definition = observable.getDescriptor();
          boolean _isUndefined_1 = definition.isUndefined();
          if (_isUndefined_1) {
            this.error("Dependency has undefined semantics", KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, 
              KimValidator.BAD_OBSERVABLE);
            ok = false;
          } else {
            if (((!definition.is(IKimConcept.Type.OBSERVABLE)) && (!definition.is(IKimConcept.Type.TRAIT)))) {
              this.error("Models can only consume observables or traits", 
                KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.BAD_OBSERVABLE);
              ok = false;
            } else {
              dependencies.add(observable);
            }
          }
          i++;
        }
      }
      EList<Contextualization> _contextualizers = model.getContextualizers();
      for (final Contextualization contextualizer : _contextualizers) {
        {
          List<KimConcept> classifiers = null;
          Classification _classification = contextualizer.getClassification();
          boolean _tripleNotEquals = (_classification != null);
          if (_tripleNotEquals) {
            classifiers = CollectionLiterals.<KimConcept>newArrayList();
            EnumSet<IKimConcept.Type> type = EnumSet.<IKimConcept.Type>noneOf(IKimConcept.Type.class);
            boolean cchecked = false;
            EList<Classifier> _classifiers = contextualizer.getClassification().getClassifiers();
            for (final Classifier classifier : _classifiers) {
              {
                KimConcept decl = Kim.INSTANCE.declareConcept(classifier.getDeclaration());
                boolean _equals = Objects.equal(type, Integer.valueOf(0));
                if (_equals) {
                  type = decl.getType();
                } else {
                }
                if ((((!Objects.equal(Boolean.valueOf(decl.is(IKimConcept.Type.SUBJECTIVE)), Integer.valueOf(0))) && (!statement.isPrivate())) && (!cchecked))) {
                  this.error("A model producing subjective observables must be private", classifier, 
                    KimPackage.Literals.CLASSIFIER__DECLARATION, KimValidator.BAD_OBSERVABLE);
                  ok = false;
                  cchecked = true;
                }
              }
            }
          }
        }
      }
      boolean _xifexpression_1 = false;
      if ((ok && (statement != null))) {
        boolean _xblockexpression_1 = false;
        {
          Namespace namespace = KimValidator.getNamespace(statement);
          boolean _xifexpression_2 = false;
          if ((namespace != null)) {
            boolean _xblockexpression_2 = false;
            {
              KimNamespace ns = Kim.INSTANCE.getNamespace(namespace, true);
              KimModel descriptor = new KimModel(statement);
              descriptor.getObservables().addAll(observables);
              descriptor.getDependencies().addAll(dependencies);
              descriptor.setInstantiator(model.isInstantiator());
              if ((interpretedRole != null)) {
                descriptor.setInterpreter(true);
                descriptor.setReinterpretingRole(interpretedRole.getMain());
              }
              Urn _urn = model.getUrn();
              boolean _tripleNotEquals = (_urn != null);
              if (_tripleNotEquals) {
                descriptor.setResourceUrn(model.getUrn().getName());
              } else {
                Function _function = model.getFunction();
                boolean _tripleNotEquals_1 = (_function != null);
                if (_tripleNotEquals_1) {
                  Function _function_1 = model.getFunction();
                  KimServiceCall _kimServiceCall = new KimServiceCall(_function_1);
                  descriptor.setResourceFunction(_kimServiceCall);
                  IServiceCall _get = descriptor.getResourceFunction().get();
                  List<KimNotification> _validateUsage = ((KimServiceCall) _get).validateUsage(null);
                  for (final KimNotification notification : _validateUsage) {
                    this.notify(notification, model.getFunction(), KimPackage.Literals.MODEL_BODY_STATEMENT__FUNCTION);
                  }
                } else {
                  String _boolean = model.getBoolean();
                  boolean _tripleNotEquals_2 = (_boolean != null);
                  if (_tripleNotEquals_2) {
                    descriptor.setInlineValue(Boolean.valueOf(Boolean.parseBoolean(model.getBoolean())));
                  } else {
                    org.integratedmodelling.kim.kdecl.Number _number = model.getNumber();
                    boolean _tripleNotEquals_3 = (_number != null);
                    if (_tripleNotEquals_3) {
                      descriptor.setInlineValue(Kim.INSTANCE.parseNumber(model.getNumber()));
                    }
                  }
                }
              }
              descriptor.setPrivate((statement.isPrivate() || ns.isPrivate()));
              descriptor.setAssessmentModel(statement.getModel().equals("assess"));
              descriptor.setLearningModel(statement.getModel().equals("learn"));
              IKimModel.Type _switchResult = null;
              String _model = statement.getModel();
              if (_model != null) {
                switch (_model) {
                  case "number":
                    _switchResult = IKimModel.Type.NUMBER;
                    break;
                  case "text":
                    _switchResult = IKimModel.Type.TEXT;
                    break;
                  case "boolean":
                    _switchResult = IKimModel.Type.BOOLEAN;
                    break;
                  default:
                    _switchResult = IKimModel.Type.SEMANTIC;
                    break;
                }
              } else {
                _switchResult = IKimModel.Type.SEMANTIC;
              }
              descriptor.setType(_switchResult);
              i = 0;
              EList<ActionSpecification> _actions = model.getActions();
              for (final ActionSpecification action : _actions) {
                {
                  IKimBehavior _behavior = descriptor.getBehavior();
                  List<KimNotification> _addAction = ((KimBehavior) _behavior).addAction(action, descriptor);
                  for (final KimNotification notification_1 : _addAction) {
                    this.notify(notification_1, model, KimPackage.Literals.MODEL_BODY_STATEMENT__ACTIONS, i);
                  }
                  i++;
                }
              }
              EList<Contextualization> _contextualizers_1 = model.getContextualizers();
              for (final Contextualization contextualizer_1 : _contextualizers_1) {
                List<IComputableResource> _contextualization = descriptor.getContextualization();
                ComputableResource _computableResource = new ComputableResource(contextualizer_1);
                _contextualization.add(_computableResource);
              }
              String _name = model.getName();
              boolean _tripleNotEquals_4 = (_name != null);
              if (_tripleNotEquals_4) {
                descriptor.name = model.getName();
              } else {
                int _size_1 = descriptor.getObservables().size();
                boolean _greaterThan_1 = (_size_1 > 0);
                if (_greaterThan_1) {
                  String _formalName = descriptor.getObservables().get(0).getFormalName();
                  boolean _tripleNotEquals_5 = (_formalName != null);
                  if (_tripleNotEquals_5) {
                    descriptor.name = observables.get(0).getFormalName();
                  } else {
                    String _xifexpression_3 = null;
                    boolean _isInstantiator = model.isInstantiator();
                    if (_isInstantiator) {
                      _xifexpression_3 = "instantiator";
                    } else {
                      _xifexpression_3 = "contextualizer";
                    }
                    String name = _xifexpression_3;
                    String _name_1 = descriptor.getObservables().get(0).getMain().getObservable().getName();
                    SemanticType st = new SemanticType(_name_1);
                    String _lowerCase = CamelCase.toLowerCase(st.getName(), '-');
                    String _plus = (_lowerCase + "-");
                    String _plus_1 = (_plus + name);
                    descriptor.name = _plus_1;
                  }
                }
              }
              Metadata _metadata = model.getMetadata();
              boolean _tripleNotEquals_6 = (_metadata != null);
              if (_tripleNotEquals_6) {
                Metadata _metadata_1 = model.getMetadata();
                KimMetadata _kimMetadata = new KimMetadata(_metadata_1);
                descriptor.setMetadata(_kimMetadata);
              }
              Documentation _documentation = model.getDocumentation();
              boolean _tripleNotEquals_7 = (_documentation != null);
              if (_tripleNotEquals_7) {
              }
              int n = 0;
              List<IKimScope> _children = ns.getChildren();
              for (final IKimScope object : _children) {
                if (((object instanceof KimModel) && ((KimModel) object).name.startsWith(descriptor.name))) {
                  n++;
                }
              }
              if ((n > 0)) {
                descriptor.name = ((descriptor.name + "-") + Integer.valueOf(n));
              }
              i = 0;
              EList<Annotation> _annotations = statement.getAnnotations();
              for (final Annotation annotation : _annotations) {
                {
                  KimAnnotation ann = new KimAnnotation(annotation, ns);
                  descriptor.getAnnotations().add(ann);
                  List<KimNotification> _validateUsage_1 = ann.validateUsage(descriptor);
                  for (final KimNotification notification_1 : _validateUsage_1) {
                    this.notify(notification_1, statement, KimPackage.Literals.MODEL_STATEMENT__ANNOTATIONS, i);
                  }
                  i++;
                }
              }
              model.setName(descriptor.name);
              _xblockexpression_2 = ns.getChildren().add(descriptor);
            }
            _xifexpression_2 = _xblockexpression_2;
          }
          _xblockexpression_1 = _xifexpression_2;
        }
        _xifexpression_1 = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression_1;
    }
    return _xblockexpression;
  }
  
  public void notify(final KimNotification notification, final EObject object, final EStructuralFeature cls) {
    final Level _switchValue = notification.level;
    boolean _matched = false;
    if (Objects.equal(_switchValue, Level.SEVERE)) {
      _matched=true;
      this.error(notification.message, object, cls);
    }
    if (!_matched) {
      if (Objects.equal(_switchValue, Level.WARNING)) {
        _matched=true;
        this.warning(notification.message, object, cls);
      }
    }
    if (!_matched) {
      if (Objects.equal(_switchValue, Level.INFO)) {
        _matched=true;
        this.info(notification.message, object, cls);
      }
    }
  }
  
  @Check
  public Object checkActionSpecification(final ActionSpecification action) {
    return null;
  }
  
  @Check
  public boolean checkObservation(final ObserveStatement observation) {
    boolean _xblockexpression = false;
    {
      KimObserver obs = this.checkObservation(observation.getBody(), null);
      boolean _xifexpression = false;
      if ((obs != null)) {
        boolean _xblockexpression_1 = false;
        {
          KimNamespace ns = Kim.INSTANCE.getNamespace(observation, true);
          int i = 0;
          EList<Annotation> _annotations = observation.getAnnotations();
          for (final Annotation annotation : _annotations) {
            {
              final KimAnnotation ann = new KimAnnotation(annotation, ns);
              obs.getAnnotations().add(ann);
              List<KimNotification> _validateUsage = ann.validateUsage(obs);
              for (final KimNotification notification : _validateUsage) {
                this.notify(notification, observation, KimPackage.Literals.OBSERVE_STATEMENT__ANNOTATIONS, i);
              }
              i++;
            }
          }
          _xblockexpression_1 = ns.getChildren().add(obs);
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public KimObserver checkObservation(final ObserveStatementBody observation, final KimObserver parent) {
    KimObserver ret = null;
    boolean ok = true;
    if ((observation == null)) {
      return null;
    }
    KimObservable semantics = Kim.INSTANCE.declareObservable(observation.getConcept());
    if ((semantics != null)) {
      if ((Objects.equal(Boolean.valueOf(semantics.getDescriptor().is(IKimConcept.Type.SUBJECT)), Integer.valueOf(0)) && Objects.equal(Boolean.valueOf(semantics.getDescriptor().is(IKimConcept.Type.EVENT)), Integer.valueOf(0)))) {
        this.error("Observations can only be created for subjects and events", observation, 
          KimPackage.Literals.OBSERVE_STATEMENT_BODY__CONCEPT, KimValidator.BAD_OBSERVATION);
        ok = false;
      } else {
        KimObserver _kimObserver = new KimObserver(observation, semantics);
        ret = _kimObserver;
      }
    }
    EList<ObserveStatementBody> _observations = observation.getObservations();
    for (final ObserveStatementBody obs : _observations) {
      {
        KimObserver child = this.checkObservation(obs, ret);
        if ((ret != null)) {
          ret.getChildren().add(child);
        } else {
          ok = false;
        }
      }
    }
    int i = 0;
    EList<ObservableSemantics> _states = observation.getStates();
    for (final ObservableSemantics state : _states) {
      {
        KimObservable stateSemantics = Kim.INSTANCE.declareObservable(state);
        Object _value = stateSemantics.getValue();
        boolean _tripleEquals = (_value == null);
        if (_tripleEquals) {
          this.error("States declared in an observe statement must specify a value followed by \'as\' and the semantics", observation, KimPackage.Literals.OBSERVE_STATEMENT_BODY__STATES, i);
          ok = false;
        } else {
          ret.getStates().add(stateSemantics);
        }
        i++;
      }
    }
    i = 0;
    EList<ActionSpecification> _actions = observation.getActions();
    for (final ActionSpecification action : _actions) {
      {
        IKimBehavior _behavior = ret.getBehavior();
        List<KimNotification> _addAction = ((KimBehavior) _behavior).addAction(action, ret);
        for (final KimNotification notification : _addAction) {
          {
            this.notify(notification, observation, KimPackage.Literals.OBSERVE_STATEMENT_BODY__ACTIONS, i);
            boolean _equals = Objects.equal(notification.level, Level.SEVERE);
            if (_equals) {
              ok = false;
            }
          }
        }
        i++;
      }
    }
    KimObserver _xifexpression = null;
    if (ok) {
      _xifexpression = ret;
    } else {
      _xifexpression = null;
    }
    return _xifexpression;
  }
  
  /**
   * get the namespace object, assuming we are not one
   */
  public static Namespace getNamespace(final EObject statement) {
    if ((statement instanceof Namespace)) {
      return ((Namespace)statement);
    } else {
      if ((statement instanceof Model)) {
        return ((Model) statement).getNamespace();
      }
    }
    EObject stat = statement;
    while (((stat != null) && (!(stat instanceof Model)))) {
      stat = stat.eContainer();
    }
    Namespace _xifexpression = null;
    if ((stat == null)) {
      _xifexpression = null;
    } else {
      _xifexpression = KimValidator.getNamespace(stat);
    }
    return _xifexpression;
  }
}
