grammar org.integratedmodelling.kdl.Kdl with org.eclipse.xtext.common.Terminals

generate kdl "http://www.integratedmodelling.org/kdl/Kdl"

/*
 * The root model is the body of the dataflow for the context observation
 */
Model:
	(('@dataflow' name=(Path|UrnId))? &
	 ('@var' variables+=Parameter)* &
	 ('@val' constants+=Parameter)* &
	 ('@author' authors+=STRING)* &
	 ('@version' version=VersionNumber)? &
	 ('@klab' klabVersion=VersionNumber)? &
	 ('@worldview' worldview=LOWERCASE_ID)? &
	 ('@geometry' geometry=Geometry)? &
	 ('@endpoint' endpoint=STRING)? &
	 ('@namespace' package=PathName)? &
	 ('@coverage' scale+=Function (',' scale+=Function)*)? &
	 ('@context' contextUrn=Urn)?) 
	actors+=ActorDefinition*;

terminal ANNOTATION_ID:
	'@' LOWERCASE_ID;
	
Annotation:
	name=ANNOTATION_ID ('(' parameters=ParameterList? ')')?;
	
ActorDefinition:
	
	/*
	 * This is the form that specifies dataflows
	 */
	
	annotations += Annotation*
	// abstract only allowed at root level; only exists to be extended
	(abstract?='abstract')?
	(final?='final')? (optional?='optional')? 
	// export and import are from a CONTEXT and refer to artifact. So 'export number' is a contextualizer that produces numbers.
	((exported?='export' | (imported?='import') (multiple?='multiple' | arity=INT (minimum?='+')?)?))? 
	// parameters denotes the ability of the implementation of accepting modified values during run
	// parameters cannot be multiple, must have a default and should have a range, can be calibrated, and will appear in calibration scenarios
	(parameter?='parameter')?
	type=ACTOR name=(LOWERCASE_ID|LOWERCASE_DASHID|STRING) 
		// extends only allowed at root level; must extend another upstream in same file
		('extends' extended=(LOWERCASE_ID|LOWERCASE_DASHID|STRING))?
		('for' targets+=TARGET (',' targets+=TARGET)*)? (docstring=STRING)? ('label' label=STRING)?
	('default' default=Value)?
	('{' body=DataflowBody '}')?
	('as' localName=LOWERCASE_ID)?
	('over' coverage+=Function (',' coverage+=Function)*)? 
	
	|

	/*
	 * This is the form to declare service prototypes - TODO probably overkill at this point
	 */

	// abstract only allowed at root level; only exists to be extended
	(abstract?='abstract')?
	// parameter for services - takes type from value if optional; default mandatory if optional; docstring is mandatory
	((optional?='optional') | type=('number' | 'boolean' | 'text' | 'list' | 'enum')) 
	// input = function parameter; import = artifact from context
	(parameter?='input'|imported?='import') name=(LOWERCASE_ID|LOWERCASE_DASHID|STRING)
	// extends only allowed at root level; must extend another upstream in same file
	('extends' extended=(LOWERCASE_ID|LOWERCASE_DASHID|STRING))?	// enum values, only for enum type
	('values' enumValues+=UPPERCASE_ID (',' enumValues+=UPPERCASE_ID)*)?
	(docstring=STRING) ('label' label=STRING)?
	('default' default=Value)?
	('{' body=DataflowBody '}')?
	(	
		('minimum' rangeMin=Number) |		
		('maximum' rangeMax=Number) |		
		('range' rangeMin=Number 'to' rangeMax=Number)
	)?;
	
DataflowBody:
	{DataflowBody}
	(dataflows+=ActorDefinition*)
	(('geometry' geometry=Geometry)? &
	('units' units=Unit)? &
	(computations=Computation)? &
	('metadata' metadata=Metadata)?
	('class' javaClass=JavaClass)?);
Computation:
	'compute' functions+=Function (',' functions+=Function)*;
Geometry:
	'*' | SHAPE (',' SHAPE)*;
Parameter:
	name=LOWERCASE_ID value=Value (docstring=STRING)?;
ACTOR:
// countable, so always a dataflow for direct object instantiation
	'object' |
	// non-countable, so one object only
	'process' |
	// any acceptable quality type, for declarations only
	'value' |
	// all the next are in quality scope; number type is handled internally
	'number' | 'concept' | 'boolean' | 'text' | 'list' |
	// specialized functions that produce extents
	'extent' | 'spatialextent' | 'temporalextent' |
	// only contracts for annotations
	'annotation' |
	// only for command prototypes
	'void' |
	// partial contextualizers for their parents
	'partition';
	
TARGET:
	'models' | 'concepts' | 'observers' | 'definitions' | 'dependencies';

ClassifierRHS:
	(boolean='true' | boolean='false') | 
	int0=Number (leftLimit='inclusive' | 'exclusive')? => 'to' => int1=Number (rightLimit='inclusive' | 'exclusive')? | 
	num=Number | 
	'in' set=List |
	string=STRING |  
	map=Map |
	'(' toResolve+=STRING (=> ',' toResolve+=STRING)* ')' | 
	op=REL_OPERATOR expression=Number |
	nodata='unknown' | 
	star?='*'; 
	
List:
	{List} '(' contents+=Value* ')';
Literal:
	number=Number | from=Number 'to' to=Number | string=STRING | boolean=('true' | 'false');
LiteralOrIdOrComma returns Literal:
	from=Number => 'to' => to=Number | number=Number | string=STRING | boolean=('true' | 'false') | id=ID | comma?=',';
LiteralOrID returns Literal:
	number=Number | string=STRING | boolean=('true' | 'false') | id=ID;
Metadata:
	{Metadata} '{' (ids+=(LOWERCASE_ID | PropertyId) values+=(LiteralOrID | Metadata | List))* '}';
ParameterList:
	values+=Value (',' values+=Value)* | pairs+=KeyValuePair (=> ',' pairs+=KeyValuePair)*;
Value:
	literal=LiteralOrIdOrComma | 
	function=Function | 
	urn=Urn | 
	list=List |
	map=Map | 
	expression=EXPR |
	table=LookupTable | 
	enumId=UPPERCASE_ID;
Urn:
// String used when there are strange chars or keywords in the URN.
	name=(UrnId | STRING | LocalFilePath);

	/**
 * URN is 4 sections and admits a version number and a fragment (with only lowercase_id chars in it). It is
 * legal, but not required, to start with the default prefix urn:klab:
 */
UrnId:
	('urn:klab:')? PathName ':' PathName ':' PathName ':' Path (':' VersionNumber)? ('#' LOWERCASE_ID)?;

Map:
	{Map} '{' (entries+=MapEntry (=> (',') entries+=MapEntry)*)? '}'
;

MapEntry:
	classifier=ClassifierRHS ':' value=Value
;


// Lookup table literal
LookupTable: {LookupTable}
	'{{' table=Table? '}}'
;

Table:
	rows+=TableRow (',' rows+=TableRow)*;

TableRow:
	elements+=TableClassifier ('|' elements+=TableClassifier)*
;

TableClassifier returns ClassifierRHS:
	(boolean='true' | boolean='false') | 
	int0=Number (leftLimit='inclusive' | 'exclusive')? => 'to' => int1=Number (rightLimit='inclusive' | 'exclusive')? |
	num=Number | 
	'in' set=List | 
	string=STRING | 
	op=REL_OPERATOR expression=Number | 
	expr=EXPR |
	nodata='unknown' |
	star?='*' |
	anything?='#';

terminal EXPR:
	'[' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | ']' | '\\') | !('\\' | ']'))* ']';
	

	/**
 * Local file paths become locally based URNs and can be used wherever URNs are accepted. Their interpretation depends
 * on whether there is an encoder for their file extension.
 */
LocalFilePath:
	(CAMELCASE_ID | LOWERCASE_ID | LOWERCASE_DASHID) ('/' (CAMELCASE_ID | LOWERCASE_ID | LOWERCASE_DASHID))* ('.'
	LOWERCASE_ID)? ('#' LOWERCASE_ID)?;
KeyValuePair:
	name=(LOWERCASE_ID|LOWERCASE_DASHID) (interactive?='=?' | '=') value=Value;
Function:
	(mediated=LOWERCASE_ID '>>')?
	((name=PathName '(' (parameters=ParameterList)? ')') | urn=Urn | value=Literal | expression=EXPR) ('as'
	variable=LOWERCASE_ID)? |
	'(' chain+=Function (',' chain+=Function)* ')' ('as' variable=LOWERCASE_ID)?;
	/**
 * ---------------------------------------
 * Unit of measurement re: jsr-108, parseable by Java
 * TODO implement expression syntax and provide validator
 * ---------------------------------------
 */
UnitElement:
	id=(CAMELCASE_ID | LOWERCASE_ID) |
	num=Number |
	'(' unit=Unit ')';
enum UnitOp:
	OVER='/' | CARET='^' | STAR='*';
REL_OPERATOR:
	(gt?='>' |
	lt?='<' |
	eq?='=' |
	ne?='!=' |
	le?='<=' |
	ge?='>=');
Unit:
	{Unit} (root=UnitElement)? (=> (connectors+=UnitOp) (units+=UnitElement))*;
Currency:
	id=ID ('@' year=INT) |
	concept=(CAMELCASE_ID | NamespaceId);
Number:
	('+' | negative?='-')? => real=INT => (decimal?='.' decimalPart=INT)? => (exponential?=('e' | 'E') ('+' |
	expNegative?='-')? exp=INT)?;
terminal LOWERCASE_ID:
	('a'..'z') ('a'..'z' | '0'..'9' | '_')*;
terminal LOWERCASE_DASHID:
	('a'..'z') ('a'..'z' | '0'..'9' | '-')*;
terminal SHAPE:
	('#') | ('#')? (('A'..'z') ('.' | ('0'..'3')))+;
PathName:
	LOWERCASE_ID ('.' LOWERCASE_ID)*;
Path:
	LOWERCASE_ID (('.' | '/') LOWERCASE_ID)*;
JavaClass:
	PathName '.' CAMELCASE_ID;
terminal UPPERCASE_ID:
	('A'..'Z') ('A'..'Z')*;
terminal UPPERCASE_PATH:
	UPPERCASE_ID ('.' UPPERCASE_ID)*;
terminal CAMELCASE_ID:
	('A'..'Z') ('A'..'z' | '0'..'9')*;
NamespaceId:
	PathName ':' CAMELCASE_ID;
PropertyId:
	PathName ':' (LOWERCASE_ID | LOWERCASE_DASHID);
VersionNumber:
	INT ('.' INT ('.' INT)?)? ('-')? ((LOWERCASE_ID | UPPERCASE_ID))?;


