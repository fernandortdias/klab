/*
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kdl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.integratedmodelling.kdl.kdl.ActorDefinition;
import org.integratedmodelling.kdl.kdl.Classification;
import org.integratedmodelling.kdl.kdl.Classifier;
import org.integratedmodelling.kdl.kdl.ClassifierRHS;
import org.integratedmodelling.kdl.kdl.Computation;
import org.integratedmodelling.kdl.kdl.Concept;
import org.integratedmodelling.kdl.kdl.ConceptDeclaration;
import org.integratedmodelling.kdl.kdl.Currency;
import org.integratedmodelling.kdl.kdl.DataflowBody;
import org.integratedmodelling.kdl.kdl.Function;
import org.integratedmodelling.kdl.kdl.KdlPackage;
import org.integratedmodelling.kdl.kdl.KeyValuePair;
import org.integratedmodelling.kdl.kdl.List;
import org.integratedmodelling.kdl.kdl.Literal;
import org.integratedmodelling.kdl.kdl.Metadata;
import org.integratedmodelling.kdl.kdl.Model;
import org.integratedmodelling.kdl.kdl.ObservableSemantics;
import org.integratedmodelling.kdl.kdl.ParameterList;
import org.integratedmodelling.kdl.kdl.REL_OPERATOR;
import org.integratedmodelling.kdl.kdl.Unit;
import org.integratedmodelling.kdl.kdl.UnitElement;
import org.integratedmodelling.kdl.kdl.Urn;
import org.integratedmodelling.kdl.kdl.Value;
import org.integratedmodelling.kdl.services.KdlGrammarAccess;

@SuppressWarnings("all")
public class KdlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KdlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KdlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KdlPackage.ACTOR_DEFINITION:
				sequence_ActorDefinition(context, (ActorDefinition) semanticObject); 
				return; 
			case KdlPackage.CLASSIFICATION:
				sequence_Classification(context, (Classification) semanticObject); 
				return; 
			case KdlPackage.CLASSIFIER:
				sequence_Classifier(context, (Classifier) semanticObject); 
				return; 
			case KdlPackage.CLASSIFIER_RHS:
				sequence_ClassifierRHS(context, (ClassifierRHS) semanticObject); 
				return; 
			case KdlPackage.COMPUTATION:
				sequence_Computation(context, (Computation) semanticObject); 
				return; 
			case KdlPackage.CONCEPT:
				sequence_Concept(context, (Concept) semanticObject); 
				return; 
			case KdlPackage.CONCEPT_DECLARATION:
				if (rule == grammarAccess.getConceptDeclarationRule()) {
					sequence_ConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleConceptDeclarationRule()) {
					sequence_SimpleConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else break;
			case KdlPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case KdlPackage.DATAFLOW_BODY:
				sequence_DataflowBody(context, (DataflowBody) semanticObject); 
				return; 
			case KdlPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case KdlPackage.KEY_VALUE_PAIR:
				sequence_KeyValuePair(context, (KeyValuePair) semanticObject); 
				return; 
			case KdlPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case KdlPackage.LITERAL:
				if (rule == grammarAccess.getLiteralOrIDRule()) {
					sequence_LiteralOrID(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralOrIdOrCommaRule()) {
					sequence_LiteralOrIdOrComma(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralRule()) {
					sequence_Literal(context, (Literal) semanticObject); 
					return; 
				}
				else break;
			case KdlPackage.METADATA:
				sequence_Metadata(context, (Metadata) semanticObject); 
				return; 
			case KdlPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KdlPackage.NUMBER:
				sequence_Number(context, (org.integratedmodelling.kdl.kdl.Number) semanticObject); 
				return; 
			case KdlPackage.OBSERVABLE_SEMANTICS:
				sequence_ObservableSemantics(context, (ObservableSemantics) semanticObject); 
				return; 
			case KdlPackage.PARAMETER:
				sequence_Parameter(context, (org.integratedmodelling.kdl.kdl.Parameter) semanticObject); 
				return; 
			case KdlPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case KdlPackage.REL_OPERATOR:
				sequence_REL_OPERATOR(context, (REL_OPERATOR) semanticObject); 
				return; 
			case KdlPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case KdlPackage.UNIT_ELEMENT:
				sequence_UnitElement(context, (UnitElement) semanticObject); 
				return; 
			case KdlPackage.URN:
				sequence_Urn(context, (Urn) semanticObject); 
				return; 
			case KdlPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActorDefinition returns ActorDefinition
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (exported?='export' | (optional?='optional'? imported?='import' (multiple?='multiple' | (arity=INT minimum?='+'?))?))? 
	 *             parameter?='parameter'? 
	 *             type=ACTOR 
	 *             (name=LOWERCASE_ID | name=LOWERCASE_DASHID | name=STRING) 
	 *             (targets+=TARGET targets+=TARGET*)? 
	 *             docstring=STRING? 
	 *             body=DataflowBody? 
	 *             localName=LOWERCASE_ID? 
	 *             (coverage+=Function coverage+=Function*)?
	 *         ) | 
	 *         (
	 *             (
	 *                 optional?='optional' | 
	 *                 type='number' | 
	 *                 type='boolean' | 
	 *                 type='text' | 
	 *                 type='list' | 
	 *                 type='enum'
	 *             ) 
	 *             parameter?='input' 
	 *             name=LOWERCASE_ID 
	 *             (enumValues+=UPPERCASE_ID enumValues+=UPPERCASE_ID*)? 
	 *             docstring=STRING 
	 *             default=Value? 
	 *             body=DataflowBody? 
	 *             (rangeMin=Number | rangeMax=Number | (rangeMin=Number rangeMax=Number))?
	 *         )
	 *     )
	 */
	protected void sequence_ActorDefinition(ISerializationContext context, ActorDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classification returns Classification
	 *
	 * Constraint:
	 *     (classifiers+=Classifier classifiers+=Classifier*)
	 */
	protected void sequence_Classification(ISerializationContext context, Classification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierRHS returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         (toResolve+=ConceptDeclaration toResolve+=ConceptDeclaration*) | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_ClassifierRHS(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classifier returns Classifier
	 *
	 * Constraint:
	 *     (declaration=ConceptDeclaration (otherwise?='otherwise' | (negated?='unless'? classifier=ClassifierRHS))?)
	 */
	protected void sequence_Classifier(ISerializationContext context, Classifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Computation returns Computation
	 *
	 * Constraint:
	 *     (functions+=Function functions+=Function*)
	 */
	protected void sequence_Computation(ISerializationContext context, Computation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptDeclaration returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (name=STRING? main+=Concept+ inherency=SimpleConceptDeclaration? context=SimpleConceptDeclaration?)
	 */
	protected void sequence_ConceptDeclaration(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns Concept
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             negated?='not'? 
	 *             name=ConceptReference 
	 *             ((stringIdentifier=ID | stringIdentifier=STRING | intIdentifier=INT) (authority=UPPERCASE_ID | authority=UPPERCASE_PATH))?
	 *         ) | 
	 *         (presence?='presence' concept=SimpleConceptDeclaration) | 
	 *         (count?='count' concept=SimpleConceptDeclaration) | 
	 *         (distance?='distance' concept=SimpleConceptDeclaration) | 
	 *         (probability?='probability' concept=SimpleConceptDeclaration) | 
	 *         (uncertainty?='uncertainty' concept=SimpleConceptDeclaration) | 
	 *         (proportion?='proportion' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (ratio?='ratio' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration) | 
	 *         (value?='value' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (occurrence?='occurrence' concept=SimpleConceptDeclaration) | 
	 *         declaration=ConceptDeclaration
	 *     )
	 */
	protected void sequence_Concept(ISerializationContext context, Concept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Currency returns Currency
	 *
	 * Constraint:
	 *     ((id=ID year=INT) | concept=CAMELCASE_ID | concept=NamespaceId)
	 */
	protected void sequence_Currency(ISerializationContext context, Currency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataflowBody returns DataflowBody
	 *
	 * Constraint:
	 *     (
	 *         (newObservation=ObservableSemantics | urnObservation=Urn)? 
	 *         dataflows+=ActorDefinition* 
	 *         geometry=Geometry? 
	 *         ((units=Unit | computations+=Computation | semantics=ObservableSemantics | metadata=Metadata | javaClass=JavaClass)? geometry=Geometry?)*
	 *     )
	 */
	protected void sequence_DataflowBody(ISerializationContext context, DataflowBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         (mediated=LOWERCASE_ID? ((name=PathName parameters=ParameterList?) | urn=Urn | value=Literal) variable=LOWERCASE_ID?) | 
	 *         (classification=Classification variable=LOWERCASE_ID?) | 
	 *         (chain+=Function chain+=Function* variable=LOWERCASE_ID?)
	 *     )
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyValuePair returns KeyValuePair
	 *
	 * Constraint:
	 *     (name=LOWERCASE_ID interactive?='=?'? value=Value)
	 */
	protected void sequence_KeyValuePair(ISerializationContext context, KeyValuePair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     contents+=Value*
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralOrID returns Literal
	 *
	 * Constraint:
	 *     (number=Number | string=STRING | boolean='true' | boolean='false' | id=ID)
	 */
	protected void sequence_LiteralOrID(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralOrIdOrComma returns Literal
	 *
	 * Constraint:
	 *     (
	 *         (from=Number to=Number) | 
	 *         number=Number | 
	 *         string=STRING | 
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         id=ID | 
	 *         comma?=','
	 *     )
	 */
	protected void sequence_LiteralOrIdOrComma(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     (number=Number | (from=Number to=Number) | string=STRING | boolean='true' | boolean='false')
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metadata returns Metadata
	 *
	 * Constraint:
	 *     ((ids+=LOWERCASE_ID | ids+=PropertyId) (values+=LiteralOrID | values+=Metadata | values+=List))*
	 */
	protected void sequence_Metadata(ISerializationContext context, Metadata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name=Path | 
	 *                 name=UrnId | 
	 *                 variables+=Parameter | 
	 *                 constants+=Parameter | 
	 *                 authors+=STRING | 
	 *                 version=VersionNumber | 
	 *                 klabVersion=VersionNumber | 
	 *                 worldview=LOWERCASE_ID | 
	 *                 geometry=Geometry | 
	 *                 endpoint=STRING | 
	 *                 package=PathName | 
	 *                 (scale+=Function scale+=Function*) | 
	 *                 contextUrn=Urn
	 *             )+ 
	 *             actors+=ActorDefinition+
	 *         ) | 
	 *         actors+=ActorDefinition+
	 *     )?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (negative?='-'? real=INT (decimal?='.' decimalPart=INT)? ((exponential?='e' | exponential?='E') expNegative?='-'? exp=INT)?)
	 */
	protected void sequence_Number(ISerializationContext context, org.integratedmodelling.kdl.kdl.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         declaration=ConceptDeclaration 
	 *         (
	 *             (
	 *                 by=Concept | 
	 *                 downTo=CAMELCASE_ID | 
	 *                 downTo=NamespaceId | 
	 *                 role=Concept | 
	 *                 unit=Unit | 
	 *                 currency=Currency | 
	 *                 unit=Unit
	 *             )? 
	 *             (from=Number to=Number)?
	 *         )+
	 *     )
	 */
	protected void sequence_ObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     ((values+=Value values+=Value*) | (pairs+=KeyValuePair pairs+=KeyValuePair*))
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=LOWERCASE_ID value=Value docstring=STRING?)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.integratedmodelling.kdl.kdl.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     REL_OPERATOR returns REL_OPERATOR
	 *
	 * Constraint:
	 *     (
	 *         gt?='>' | 
	 *         lt?='<' | 
	 *         eq?='=' | 
	 *         ne?='!=' | 
	 *         le?='<=' | 
	 *         ge?='>='
	 *     )
	 */
	protected void sequence_REL_OPERATOR(ISerializationContext context, REL_OPERATOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleConceptDeclaration returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (name=STRING? main+=Concept+)
	 */
	protected void sequence_SimpleConceptDeclaration(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns UnitElement
	 *
	 * Constraint:
	 *     (id=CAMELCASE_ID | id=LOWERCASE_ID | num=Number | unit=Unit)
	 */
	protected void sequence_UnitElement(ISerializationContext context, UnitElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (root=UnitElement? (connectors+=UnitOp units+=UnitElement)*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Urn returns Urn
	 *
	 * Constraint:
	 *     (name=UrnId | name=STRING | name=LocalFilePath)
	 */
	protected void sequence_Urn(ISerializationContext context, Urn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (
	 *         literal=LiteralOrIdOrComma | 
	 *         function=Function | 
	 *         (urn=Urn unit=Unit) | 
	 *         currency=Currency | 
	 *         list=List | 
	 *         enumId=UPPERCASE_ID
	 *     )
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
