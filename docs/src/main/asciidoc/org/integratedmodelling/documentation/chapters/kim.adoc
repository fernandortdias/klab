= The k.IM semantic modeling language
:doctype: book

The k.LAB software stack utilizes three different domain-specific languages to support the semantic modelling workflow:

k.IM:: is used to define _semantic assets_, both conceptual (ontologies that become part of _worldviews_ and computational (_models_ that pair semantics with URN-specified _resources_ or inline computations executed by the k.LAB modeling _engine_).

k.Actors:: is used to specify reactive _behaviors_ for the different agents created during a k.LAB session, including observations of all kinds. By extending the notion of _agent_ to k.LAB users and sessions, k.Actors also enables the definition of specific applications that implement custom user interfaces and support specialized workflows.

k.DL:: is the _dataflow_ language that k.LAB uses to represent, store and communicate any computational strategy built to respond to a semantic query. Users are normally not aware of k.DL resources (except through their graphical representation built to document a contextualization) but they can be extracted, saved, and stored as resources that can be published and re-annotated in k.IM. This allows treating k.LAB outputs as inputs and enables reproducibility and provenance analysis across the lifecycle of k.LAB products.

This chapter documents k.IM, the most important k.LAB language for the user. All knowledge used by k.LAB is specified in k.IM, a small, declarative language designed to be used with the concepts from a shared <<TBD,worldview>> to build logical statements representing scientific knowledge. The k.IM language is designed to be easily readable even by k.IM-illiterate readers. Readability is obtained by manipulating real-life concepts using a syntax that is closely modeled after the rules and conventions of the English grammar. Knowledge of k.IM is not required in order to _use_ k.LAB to make observations; it is, however, necessary to contribute to conceptualizations, build models and annotate resources. This section describes in detail how k.IM is designed and how to write conceptualizations, data annotations and model logics in it.


[#section-kim-overview]
== Overview

k.IM is a _declarative_ language: when k.LAB reads correct k.IM source code, it does not _do_ anything visible to the user, or produce any outputs of relevance. It merely ingests the knowledge specified in the k.IM statements, validates it, and catalogs it for later use. In that sense, k.IM can be considered a language to build a database of semantically coherent "facts" (a _knowledge base_) that can be used to do what k.LAB does: _contextualize_ concepts to produce their observations, as you have learned <<chapter-overview,previously>>. Because k.LAB is a _distributed_ system, made up of many networked nodes that talk to each other, that knowledge can become available also to any other user connected to the same network, according to where k.IM code is stored and to rules and preferences set in k.IM itself. All k.IM code on public nodes of the k.LAB network contributes to a _distributed knowledge base_, which every user can exploit to make observations and build upon to produce new knowledge.

NOTE: about English and why English.

The most important types of knowledge that can be specified (we will use the word _declared_ in the following) in k.IM are *concepts* and *models*. In a nutshell:

Concepts:: MORE ON THEM (introduce the worldview here). The k.IM language produces fully compliant and consistent OWL2 data structures
Models:: The purposes of models is to _contextualize_ concepts, i.e. _build an observation of them in a context_. (for later: Contextualization is split in two broad categories: _resolution_ and _instantiation_.) In k.IM, we make no difference between the commonly dichotomic categories of _data_ and _models_: the instruction "model X" means build an observation of X, no matter whether the final source of the computed artifact is a stored dataset or a computation.


Before we describe how concepts and models are declared in k.IM, we must spend a few words to describe how k.IM statements are organized and stored. The easiest way to follow the content of this section is to have the k.LAB <<chapter-modeler,Modeler>> opened in front of you, with one or more k.IM projects loaded: you can easily do so by following our <<setup-modelers,setup instructions>> for k.LAB modelers.
 
=== Projects and namespaces

Projects

Namespaces

Annotations (introduce briefly)

=== Lifecycle of a project

[#section-kim-syntax]
== k.IM syntax

As introduced before, the k.IM language recognizes just two main types of statements: _concept definitions_ and _model definitions_. Concept definitions create new concepts, automatically connecting them to the k.LAB core ontology and to concepts defined in other namespaces. Model definitions specify how to produce scientific artifacts (observations) of specified concepts. Although a k.IM namespace can contain both types of statements, the two classes of statements are normally used by different kinds of contributors. Only those users that contribute to worldviews - a collaborative process that requires significant time, expertise and logical skills - normally need to use concept definition statements, which compose _worldviews_, i.e. conceptualizations that cover a broad range of disciplines and allow modelers to annotate data and computations. Because worldviews are shared automatically across k.LAB users based on the preferences stored with their certificates, the majority of k.LAB modelers can just use the worldview concepts to compose _observables_ to use in models. Still, the worldview and its definition in k.IM remains available for everyone to explore (or propose changes to), and understanding the basis of the logical part of k.IM is useful for all users. More details about the community process that can support building the most useful worldviews are given later.

Within these two categories of statements considerable syntactic variation is possible. Each statement is always introduced by a keyword, i.e. a reserved word that can only be used as such (for example, keywords cannot be used as part of a namespace identifier or a dependency name). Keywords are always lowercase and they often correspond to commonly used English words. The editor incorporated in k.Modeler highlights all keyword in a bold purple color, to make them easy to recognize as you type.

The keywords that introduce _concept_ definitions represent commonly used base concepts in scientific observations. These correspond to base types in the k.LAB core observation ontology and establish the basic nature of the observable concept they introduce. Because these core types are well defined and immutable, there is no *-concept+* keyword in k.IM, and all conceptual definitions will start with a concrete type keyword such as *+agent+*, *+process+*, *+temperature+* or *+uncertainty+*. In comparison, _model_ definitions are simpler: the keyword *+model+* introduces most of them. Special categories of models include _non-semantic models_ (introduced by a data type keyword, one of *+number+*, *+boolean+* or *+text+*) and _learning models_ introduced by *+learn+*.

Other keywords in k.LAB are used to connect concepts (_semantic operators_) and to support the definition of models. These are chosen within the prepositions, adverbs, conjunctions and verbs in the English language, so they rarely conflict with user-defined names, which are normally English nouns. To efficiently represent observation activities in science and in order to ensure an intuitive match with the English language, k.IM has a high number of keywords: the following table lists all the keywords recognized in k.IM by their role in the language.

.Keywords in k.IM
|====
|Concept keywords |Model keywords| Modifiers and other reserved words
| acceleration,  
 agent,  
 amount,  
 angle, 
 area,  
 attribute,  
 bond,  
 change,  
 charge, 
 class,
 count,  
 distance, 
 domain,  
 duration,  
 electric-potential,
 energy,
 entropy,
 extent,
 event,  
 identity,  
 length,
 level,
 magnitude,  
 mass,  
 money,  
 object,  
 occurrence,  
 ordering,  
 percentage,  
 presence,  
 pressure,  
 priority,  
 probability,  
 process,  
 proportion,  
 quality,  
 quantity,  
 ratio,  
 realm,  
 relationship,  
 resistance,  
 resistivity,  
 role,  
 temperature,  
 thing,  
 uncertainty,  
 value,  
 velocity,  
 viscosity,  
 volume,  
 weight  |model, learn, boolean, number, text |  abstract,
 according,
 adjacent,
 affects,
 aggregated,
 and,
 any,
 applies,
 as,
 at,
 authority,
 averaged,
 away,
 between,
 boolean,
 by,
 causant,
 caused,
 causing,
 changed,
 children,
 classified,
 classifies,
 compresent,
 confers,
 configuration,
 consists,
 constituent,
 contained,
 container,
 containing,
 contains,
 context, 
 cooccurrent,
 core,
 covering,
 creates,
 date,
 decreases,
 define,
 defines,
 definition,
 deliberative,
 deniable,
 describes,
 discretized,
 discretizes,
 disjoint,
 do,
 down,
 during,
 each,
 equals,
 exactly,
 exclusive,
 extends,
 false,
 finally,
 float,
 follows,
 for,
 from,
 functional,
 has,
 identified,
 if,
 implies,
 imports,
 in,
 inclusive,
 increases,
 inherent,
 inherits,
 initialization,
 instantiation,
 integer,
 integrate,
 interactive,
 into,
 inverse,
 is,
 language,
 learn,
 least,
 linking,
 links,
 lookup,
 marks,
 metadata,
 minus,
 monetary,
 more,
 most,
 move,
 named,
 namespace,
 no,
 not,
 nothing,
 number,
 observe,
 observing,
 of,
 on,
 only,
 optional,
 or,
 otherwise,
 outside,
 over,
 parameters,
 part,
 per,
 plus,
 private,
 project,
 purpose,
 rate,
 reactive,
 related,
 required,
 requires,
 rescaling,
 resolve,
 root,
 scenario,
 set,
 structural,
 subjective,
 summed,
 targeting,
 termination,
 then,
 times,
 to,
 total,
 transition,
 true,
 type,
 unknown,
 unless,
 uses,
 using,
 version,
 void,
 where,
 with,
 within,
 without,
 worldview |
|====

In addition, _separators_ (;,) are used to terminate or join statements; parentheses and brackets ({} []) may delimit concepts in _observable expressions_, _code expressions_ and tables; some symbols (\#,&,*,+,-,.,/,:,<,!=,=,>,?,@,BC,AD,E,,^,CE,e,l,|,{{,}},${,#[,==,<=,>=,?=) are recognized as _value operators_ or as part of _unit_, _currency_ _classification_, _date_, _number_ and _lookup table_ syntax.

=== Namespace declarations

=== Main statements: concepts and models

==== Concept declarations

The _general form_ of a concept declaration can be explained using <> for language elements, [] for optional code segments, and {a | b | ...} for alternative forms. The general form for a concept declaration is as follows:

.General concept declaration syntax

```
<modifiers> <concept_keyword> <name> 
    ["documentation string"]
    [{
        is {                                  <1>
          <concept_expression>       |
          <core derivation>          |
          <authority identification> |
          nothing
         }
          |
        [equals <concept_expression>]
    }]
    has [[disjoint] children                  <2>
            {
                <name>  |
                ( <concept declaration> )
            }, ...
        ]
    [requires ]                              <3>
    [applies to ]                            <4>
    [describes ]
    [part of ]                               <5>
    [constituent of ]
    [consists of ]
    [inverse of ]
    [links ]
    [increases with ]        
    [decreases with ]
    [marks with ]
    [classifies ]
    [discretizes ]
    [inherits ]                              <6>
    [has role ]                              <7>
    [implies ]                               
    [confers ]                               <8>
    [affects ]
    [creates ]
    [uses authority ]                        <9>
    [defines 
      { 
        [authority <AUTHORITY>] | 
        <upper ontology concept> 
      }
    ]
    [<property restriction> [<property restriction>...]] <10>
    [metadata <map>]                         <11>
    
```
Concepts are, by mandatory convention, named using _camelcase_ notation, with the first letter uppercase and every other letter lowercase unless it delimits another word in the same identifier (e.g. StreamOrder). The order of the grammatical elements (generally named _clauses_) after the name and optional docstring is arbitrary. The most important clauses define the lineage of the concept: its _parent_ (1) and its _children_ (2). Together they are used to define the concept hierarchy across the worldview. Parent concepts may pertain to different namespaces, which must be imported explicitly in the namespace declaration if they are part of the same project.

The following sections will expand on each of the elements above, explaining their role and the restrictions to their use. If you do not plan to get serious in collaborating to building worldviews, the meaning of the statements when read as an English sentence should be enough guidance to understand k.IM concept declaration without further reading. 

==== Model declarations

A _model_ in k.LAB represent a strategy to observe a concept in a context, producing an observation (a scientific artifact) of that concept in that context. As explained in the introduction, this definition of a model applies to both data and computations. Models have the role of _semantic annotations_, linking non-semantic informational resources to concepts and stating, if needed, which other concepts need to be observed in order to make the observation. The non-semantic resources may be explicitly represented by URNs or be implicitly defined as values (for example directly annotating a number), equations or external computations in the k.LAB engine, referred to using a function call with parameters. The syntax of models strives to keep these details intuitive and to provide the same kind of readability that concept declarations aim to.

The syntax of model statements, like that of concept statements, provides various clauses whose use depends on the type of model being written. Each model makes one of several types of observations, summarized later in 

=== Other language elements

==== Annotations

==== Definitions


[#section-kim-concepts]
== Concept declaration

..Additional statements and rules pertaining to worldviews, to align with upper ontologies, declare domains etc. See the <<TBD,specific section on worldviews>> for more.

=== Observable concepts

.Types of observables 
[plantuml, format=svg, opts="inline"]
----
legend
Observable
|_ Element 1
  |_ Element 1.1
  |_ Element 1.2
|_ Element 2
  |_ Element 2.1
end legend
----

=== Configurations

=== Predicates

.Types of predicates 
[plantuml, format=svg, opts="inline"]
----
legend
Predicate
|_ Element 1
  |_ Element 1.1
  |_ Element 1.2
|_ Element 2
  |_ Element 2.1
end legend
----

=== Abstract status

=== Parent derivation and aliasing

=== Children declaration

[#section-kim-logical-expressions]
=== Combining concepts: logical expressions

Preamble on main k.IM semantic principles. Why the "single concept" model prevents integration. How this maps to OWL.

...Orthogonality

...Parsimony

...Abstract attribution in rules

==== Semantic operators

Semantic operators are k.IM keywords that can be added to concepts to transform them into different concepts. They can unary (applying to only one concept following them) or binary (joining two different concepts). Some operators are, for readability, expressed as two words (e.g. *+percentage of+*) or even as small sentences (e.g. *+ratio of+* ConceptX *+to+* ConceptY). Their role is important because they enable parsimony of specification: by having commonly used semantic transformations of observables expressed through operators (e.g. *+uncertainty of+* geography:Elevation) we do not need to create more concepts than necessary and we can keep the worldview smaller and easier to learn and navigate.


All _unary operators_ change observables of various types into qualities that represent a particular aspect of those observables or of their observation. The following table lists the unary semantic operators in k.IM:

.Unary semantic operators in k.IM
[cols="3", options="header"]
|===
|Operator
|Applies to
|Description

|not
|Deniable attributes
|pippa
|presence of
|Countables
|pippa
|proportion of [... in]
|Qualities
|pippa
|percentage of [... in]
|Predicate [in Quality]
|pippa
|ratio of ... to
|Quality or Attribute to Quality or Attribute
|pippa
|distance {to\|from}
|Countables
|pippa
|probability of
|Events
|pippa
|uncertainty of
|Qualities
|pippa
|count of
|Countables
|pippa
|[monetary] value of [...over]
|Countables, Processes, Configurations
|pippa
|occurrence of
|Countables
|pippa
|change in
|Qualities
|pippa
|changed
|Qualities
|pippa
|change rate of
|Qualities
|pippa
|magnitude of
|Quantifiables
|pippa
|level of
|Quantifiables
|pippa
|type of
|Predicates
|pippa
|===

Binary operators do not alter the basic semantics of a concept but restrict it with conditions, creating _subclasses_ of the same concepts that match specific conditions. Importantly, these operators may define or affect the _context_ of observation and the _inherency_ of particular observables, a crucial component of observation semantics and a major driver of behavior in k.LAB. 

.Binary semantic operators in k.IM
[cols="3", options="header"]
|===
|Operator
|Operands
|Description

|within [... each]
|Observable *+within+* Countable
|Context operator
|of [...each]
|Concept
|Inherency operator
|for
|Process,Event *+for+* Configuration
|Intentionality operator
|with
|Concept
|Compresence operator
|caused by
|Concept
|Passive causality operator
|adjacent to
|Concept
|Adjacency operator
|contained in
|Concept
|Passive containment operator
|containing
|Concept
|Active containment operator
|causing
|Concept
|Active causality operator
|during
|Events
|Concurrency operator
|linking ... to
|Relationships
|Mutual interaction operator
|===


=== On properties, roles and attributes

- OWL properties can be declared (syntax later)
- Yet, using properties can lead to more obscure semantics where using roles and attributes keeps their meaning out in the open. Example: limiting factors as a property or as a role with implications.

=== The root-level concept and its role in k.LAB

=== Authorities

=== Macros

[#section-kim-observables]
== Observable declaration

Observables are *semantic queries* that specify one *observable* concept. They are used to express the semantics of an observation in queries and in models. A user can type an observable in k.Explorer and obtain an observation as the result of its contextualization. <<section-kim-models, k.IM models>> use observables to specify their inputs and outputs. For this reason, it is important to be very familiar with the way observables are declared.

An observable declaration is a k.IM <<section-kim-logical-expressions,logical expression>> that mentions one observable concept, augmented with any predicate or specifier desired, and followed by optional, additional observation semantics. The logical expression in the observable specifies _what_ is observed, where the additional semantics may impose constraints on _how_ it is observed, for example specifying a range, currency or unit of measurement for the values:

[source,kim]
----
// range
value of behavior:Outdoor behavior:Recreation behavior:Activity 0 to 1

// unit
geography:Elevation in m

// currency
economics:Income within demography:Household in EUR@2002
----


In the example above, the range `0 to 1` and the unit or currency after `in` are part of the additional syntax introduced compared to a naked logical expressions. Such specifications affect the _value_, i.e. the scaling of the numbers in the result, and do not affect the _meaning_ of what is observed, therefore their specification is not part of the _semantics_: as a consequence, observables can only be used in models (i.e., it is illegal to use units in a concept declaration, for example after 'is').

A full set of _value operators_ is also available in observables, to enable on-the-fly computations that can range from simple to complex:

[source,kim]
----
geography:Elevation in m >= 300

ecology:Vegetation chemistry:Carbon im:Mass by landcover:LandCoverType

soil:Soil chemistry:Carbon im:Mass by (landcover:LandCoverType without landcover:Urban)

economics:Income within demography:Household in USD@2000 where (landcover:LandCoverType is landcover:LowDensityUrban) by policy:Country
---- 

Such queries are all valid observables, and can be used as queries in k.Explorer or any client, or as dependencies in a k.IM model, saving much tedious coding when using the values in computation. All of them modify the _values_ and not the _meaning_. They come in particularly handy when values are distributed, like in spatially explicit observations with multiple values. The currently available value operators are:

[cols="3", options="header"]
|===
|Operator
|Applies to
|Description

|by
|Quantifiable *+by+* Class or Countable
|Groups the values of the quality it is applied to by either the value of the operand or the presence of a distinct countable. Causes the production of a table of aggregated values in the documentation associated to the observation activity.

|down to
|Class *+down to+* {Class\|<integer>}
|Produces 

|where (...)
|Quality where ( Observable )
|Shite


|>, >=, <, \<=, =, ==
|Quantifiable
|Shite

|is
|Class *+is+* subClass
|Shite

|without
|Class *+without+* Class
|Shite

|plus, minus, times, over
|Quantifiable *+plus+* {Quantifiable\|number}
|Shite

|summed, averaged
|Concept
|Shite

|total
|Concept
|Shite

|===

Observable syntax is not limited to setting constraints on values of qualities; it may also specify less obvious constraints on the observation of the inherent type. For example

[source, kim]
----
im:Orientation of each earth:Site 
----

is a logical expression that contains a keyword `each` that would not be admitted in a concept declaration, as it affects the _way_ this attribute is resolved (by resolving a _set_ of sites first, then classifying the abstract orientation to a concrete attribute in each) rather than its inherent meaning. Such forms are used to declare classifier models, which will be discussed <<section-kim-models,later>>.

=== Ranges, units and currencies

=== Value operators



=== Rules of composition for observables

[#section-kim-models]
== Models

A model is the declaration of an *observation activity*, which produces one or more semantic informational artifact (an *observation*) by enacting a computation that may use non-semantic <<TBD,resources>>, other observations (<<TBD,dependencies>>) and computational processes either from the local engine or from integrated tooling.

A model's outputs are declared semantically and are referred to as its _observables_, i.e. the concepts that the model defines an observation strategy for; its inputs, also stated using pure semantics, as _dependencies_. For example, in the following simple model:

[code,kim]
----
simple model with observables and dependencies
----

the ....

When a model declaration is processed by k.LAB, it is added to the <<TBD-kbox,knowledge base>> as a possible strategy to observe the concepts stated in the observables. When a query for the observation of a concept is made to k.LAB, either by a user (for example using k.Explorer) or to resolve a dependency of an upstream model, the system's _resolver_ algorithm will use the entire knowledge base (including any models made available on the k.LAB network) to pick the best model available for the concept stated in the query, according to scale, context and other criteria. When a model is chosen, its dependencies and external resources must also resolve and be available; if they don't, k.LAB will backtrack and fall back to the next best model, until the query can be answered or failure is declared. The resolution process and the criteria used in it are explained in detail <<TBD,later>>.

=== Types of models 

Models can be differentiated according to the type of observation activity they perform. In k.LAB, we distinguish two main types of observation, which separate into others, for a total of six different types. The syntax of the models changes little from one to the other, as it is (mostly) the observable semantics that defines the model, but there are different constraints on what can or cannot be asked to a model for each of them.

The two main types of observation activity are:

Resolution:: xxxx
Instantiation:: xxxx

These can be further differentiated according to the observable they apply to, obtaining the taxonomy below. The <<TBD,provenance>> analysis in k.LAB uses these categories, corresponding to concepts in the <<TBD,core observation ontology>>, when documenting the process that has built an observation.

.Types of observations made using models
[cols="3", options="header"]
|===
|Activity
|Base type
|Description

|Quantification
|Resolution
|The attribution of values of a numeric quality in a context.

|Verification
|Resolution
|The attribution of the presence or absence value of a countable in a context.

|Categorization
|Resolution
|The attribution of a concrete type (category) for a given entity in a context.

|Simulation
|Resolution
|The reproduction of the dynamics of a process through time.

|Detection
|Resolution
|The detection of a particular configuration engendered by other observation in the context.

|Acknowledgement
|Instantiation
|The acknowledgement of zero or more artifacts representing the observations of a countable type in the context.

|Classification
|Instantiation
|The attribution of the concrete value of an abstract predicate to all the observed countables of a type in the context.

|Explanation
|Resolution
|The observation of the detailed nature of a specific countable.

|Characterization
|Resolution
|The acknowledgement of a classified predicate on a specific countable.
|===

The categories above may read abstract, but in fact they do nothing but categorize cognitive activities that we perform every day when interacting with reality. The good news is that the observation activity expressed in each model follows directly from the semantics and does not need to be declared explicitly. Yet, it is important to be aware of what each model does, in order to avoid surprises and to understand any error messages. By understanding the semantics stated in k.IM, the observation activity should be transparent, as the syntax rules of k.IM are meant to express the activity in a form that is close to its description in the English language. In the following, we provide examples of models that clarify these different types of observation activities and how k.IM allows to state that in an intuitive and direct way.

NOTE: examples of each type of model and the dependency they may satisfy.

Observables are listed after the keyword `model` that introduces the statement. The keyword `observing` introduces a comma-separated list of dependencies. Dependencies and observables are merely <<#section-kim-observables,k.IM observables>>, i.e. pure semantics. In addition to observables and dependencies, a model can specify resources, contextualizers and actions to use as sources of "raw", non-semantic information or to define what to do with the outputs before they reach the k.LAB ecosystem as observations.

A model is declared in k.IM following this simple prototype:

[code,kim]
----
... example
----

...

=== Observables

=== Dependencies

=== Resources

NOTE: need a section specifically for these. Just describe their use in models here.

Resources can be built by models:
1. each output can be exported as a resource (caching functions in the explorer). 
2. learning models produce computable resources. 
3. Every time a dataflow is created (refs), it can be exported as a resource for repeatable computation.

=== Action statements

Composed of a _trigger_ part (possibly implicit) and an _action_ part. 

==== Triggers

===== on <event>

Event can be the keyword `definition`

Absence of a trigger is equivalent to `on definition`:

[code,kim]
----
example
----

===== over <extent>

==== Actions

===== set [target] to <expression>

===== integrate [target] to <expression>

===== do <expression>

==== Expressions

NOTE: need specific section for the language

=== Contextualizers

=== Scale constraints and how to influence them

=== Value constraints: units and extensive/intensive nature

=== Non-semantic models

=== Learning models

=== Documenting models

NOTE: subsection!

[#section-kim-defines]
== Definitions

Mixed content