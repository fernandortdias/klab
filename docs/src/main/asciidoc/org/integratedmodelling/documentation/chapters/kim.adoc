= The k.IM semantic modeling language
:doctype: book

All knowledge used by k.LAB is specified in k.IM, a small, declarative language designed to be used with the concepts from a shared <<TBD,worldview>> to build easily readable statements (even by k.IM-illiterate readers). Readability is obtained by manipulating real-life concepts using a syntax that is closely modeled after the rules and conventions of the English grammar. Knowledge of k.IM is not required in order to _use_ k.LAB to make observations; it is, however, necessary to contribute to conceptualizations, build models and annotate resources. This section describes in detail how k.IM is designed and how to write conceptualizations, data annotations and model logics in it.

[#section-kim-overview]
== Overview

k.IM is a _declarative_ language: when k.LAB reads correct k.IM source code, it does not _do_ anything visible to the user, or produce any outputs of relevance. It merely ingests the knowledge specified in the k.IM statements, validates it, and catalogs it for later use. In that sense, k.IM can be considered a language to build a database of semantically coherent "facts" (a _knowledge base_) that can be used to do what k.LAB does: _contextualize_ concepts to produce their observations, as you have learned <<chapter-overview,previously>>. Because k.LAB is a _distributed_ system, made up of many networked nodes that talk to each other, that knowledge can become available also to any other user connected to the same network, according to where k.IM code is stored and to rules and preferences set in k.IM itself. All k.IM code on public nodes of the k.LAB network contributes to a _distributed knowledge base_, which every user can exploit to make observations and build upon to produce new knowledge.

NOTE: about English and why English.

The most important types of knowledge that can be specified (we will use the word _declared_ in the following) in k.IM are *concepts* and *models*. In a nutshell:

Concepts:: MORE ON THEM (introduce the worldview here). 
Models:: Also mention the data/model equivalence.

Before we describe how concepts and models are declared in k.IM, we must spend a few words to describe how k.IM statements are organized and stored. The easiest way to follow the content of this section is to have the k.LAB <<chapter-modeler,Modeler>> opened in front of you, with one or more k.IM projects loaded: you can easily do so by following our <<setup-modelers,setup instructions>> for k.LAB modelers.
 
=== Projects and namespaces

Projects

Namespaces

Annotations (introduce briefly)

=== Lifecycle of a project


[#section-kim-concepts]
== Concept declaration

..Additional statements and rules pertaining to worldviews, to align with upper ontologies, declare domains etc. See the <<TBD,specific section on worldviews>> for more.

=== Observable concepts

=== Configurations

=== Predicates

=== Abstract status

=== Parent derivation and aliasing

=== Children declaration

[#section-kim-logical-expressions]
=== Combining concepts: logical expressions

Preamble on main k.IM semantic principles. Why the "single concept" model prevents integration. How this maps to OWL.

...Orthogonality

...Parsimony

...Abstract attribution in rules

==== Semantic modifiers


===== Unary operators

..make observables into qualities

===== Binary operators

..restrict the original semantics with conditions


=== On properties, roles and attributes

- OWL properties can be declared (syntax later)
- Yet, using properties can lead to more obscure semantics where using roles and attributes keeps their meaning out in the open. Example: limiting factors as a property or as a role with implications.

=== The root-level concept and its role in k.LAB

=== Authorities

=== Macros

[#section-kim-observables]
== Observable declaration

Observables are *semantic queries* that specify one *observable* concept. They are used to express the semantics of an observation in queries and in models. A user can type an observable in k.Explorer and obtain an observation as the result of its contextualization. <<section-kim-models, k.IM models>> use observables to specify their inputs and outputs. For this reason, it is important to be very familiar with the way observables are declared.

An observable declaration is a k.IM <<section-kim-logical-expressions,logical expression>> that mentions one observable concept, augmented with any predicate or specifier desired, and followed by optional, additional observation semantics. The logical expression in the observable specifies _what_ is observed, where the additional semantics may impose constraints on _how_ it is observed, for example specifying a range, currency or unit of measurement for the values:

[source,kim]
----
// range
value of behavior:Outdoor behavior:Recreation behavior:Activity 0 to 1

// unit
geography:Elevation in m

// currency
economics:Income within demography:Household in EUR@2002
----

In the example above, the range `0 to 1` and the unit or currency after `in` are part of the additional syntax introduced compared to a naked logical expressions. Such specifications affect the _value_, i.e. the scaling of the numbers in the result, and do not affect the _meaning_ of what is observed, therefore their specification is not part of the _semantics_: as a consequence, observables can only be used in models (i.e., it is illegal to use units in a concept declaration, for example after 'is').

A full set of _value operators_ is also available in observables, to enable on-the-fly computations that can range from simple to complex:

[source,kim]
----
geography:Elevation in m >= 300

ecology:Vegetation chemistry:Carbon im:Mass by landcover:LandCoverType

soil:Soil chemistry:Carbon im:Mass by (landcover:LandCoverType without landcover:Urban)

economics:Income within demography:Household in USD@2000 where (landcover:LandCoverType is landcover:LowDensityUrban) by policy:Country
---- 

Such queries are all valid observables, and can be used as queries in k.Explorer or any client, or as dependencies in a k.IM model, saving much tedious coding when using the values in computation. All of them modify the _values_ and not the _meaning_. They come in particularly handy when values are distributed, like in spatially explicit observations with multiple values. The currently available value operators are:

[cols="3", options="header"]
|===
|Operator
|Operands
|Description

|With
|Concept
|Shite
|===

Observable syntax is not limited to setting constraints on values of qualities; it may also specify less obvious constraints on the observation of the inherent type. For example

[source, kim]
----
im:Orientation of each earth:Site 
----

is a logical expression that contains a keyword `each` that would not be admitted in a concept declaration, as it affects the _way_ this attribute is resolved (by resolving a _set_ of sites first, then classifying the abstract orientation to a concrete attribute in each) rather than its inherent meaning. Such forms are used to declare classifier models, which will be discussed <<section-kim-models,later>>.

=== Ranges, units and currencies

=== Value operators



=== Rules of composition for observables

[#section-kim-models]
== Models

A model is the declaration of an *observation activity*, which produces one or more semantic informational artifact (an *observation*) by enacting a computation that may use non-semantic <<TBD,resources>>, other observations (<<TBD,dependencies>>) and computational processes either from the local engine or from integrated tooling.

A model's outputs are declared semantically and are referred to as its _observables_, i.e. the concepts that the model defines an observation strategy for; its inputs, also stated using pure semantics, as _dependencies_. For example, in the following simple model:

[code,kim]
----
simple model with observables and dependencies
----

the ....

When a model declaration is processed by k.LAB, it is added to the <<TBD-kbox,knowledge base>> as a possible strategy to observe the concepts stated in the observables. When a query for the observation of a concept is made to k.LAB, either by a user (for example using k.Explorer) or to resolve a dependency of an upstream model, the system's _resolver_ algorithm will use the entire knowledge base (including any models made available on the k.LAB network) to pick the best model available for the concept stated in the query, according to scale, context and other criteria. When a model is chosen, its dependencies and external resources must also resolve and be available; if they don't, k.LAB will backtrack and fall back to the next best model, until the query can be answered or failure is declared. The resolution process and the criteria used in it are explained in detail <<TBD,later>>.

=== Types of models 

Models can be differentiated according to the type of observation activity they perform. In k.LAB, we distinguish two main types of observation, which separate into others, for a total of six different types. The syntax of the models changes little from one to the other, as it is (mostly) the observable semantics that defines the model, but there are different constraints on what can or cannot be asked to a model for each of them.

The two main types of observation activity are:

Resolution:: xxxx
Instantiation:: xxxx

These can be further differentiated according to the observable they apply to, obtaining the taxonomy below. The <<TBD,provenance>> analysis in k.LAB uses these categories, corresponding to concepts in the <<TBD,core observation ontology>>, when documenting the process that has built an observation.

[cols="3", options="header"]
|===
|Activity
|Base type
|Description

|Quantification
|Resolution
|The attribution of values of a numeric quality in a context.

|Verification
|Resolution
|The attribution of the presence or absence value of a countable in a context.

|Categorization
|Resolution
|The attribution of a concrete type (category) for a given entity in a context.

|Simulation
|Resolution
|The reproduction of the dynamics of a process through time.

|Detection
|Resolution
|The detection of a particular configuration engendered by other observation in the context.

|Acknowledgement
|Instantiation
|The acknowledgement of zero or more artifacts representing the observations of a countable type in the context.

|Classification
|Instantiation
|The attribution of the concrete value of an abstract predicate to all the observed countables of a type in the context.

|Explanation
|Resolution
|The observation of the detailed nature of a specific countable.

|Characterization
|Resolution
|The acknowledgement of a classified predicate on a specific countable.
|===

The categories above may read abstract, but in fact they do nothing but categorize cognitive activities that we perform every day when interacting with reality. The good news is that the observation activity expressed in each model follows directly from the semantics and does not need to be declared explicitly. Yet, it is important to be aware of what each model does, in order to avoid surprises and to understand any error messages. By understanding the semantics stated in k.IM, the observation activity should be transparent, as the syntax rules of k.IM are meant to express the activity in a form that is close to its description in the English language. In the following, we provide examples of models that clarify these different types of observation activities and how k.IM allows to state that in an intuitive and direct way.

NOTE: examples of each type of model and the dependency they may satisfy.

Observables are listed after the keyword `model` that introduces the statement. The keyword `observing` introduces a comma-separated list of dependencies. Dependencies and observables are merely <<#section-kim-observables,k.IM observables>>, i.e. pure semantics. In addition to observables and dependencies, a model can specify resources, contextualizers and actions to use as sources of "raw", non-semantic information or to define what to do with the outputs before they reach the k.LAB ecosystem as observations.

A model is declared in k.IM following this simple prototype:

[code,kim]
----
... example
----

...

=== Observables

=== Dependencies

=== Resources

NOTE: need a section specifically for these. Just describe their use in models here.

Resources can be built by models:
1. each output can be exported as a resource (caching functions in the explorer). 
2. learning models produce computable resources. 
3. Every time a dataflow is created (refs), it can be exported as a resource for repeatable computation.

=== Action statements

Composed of a _trigger_ part (possibly implicit) and an _action_ part. 

==== Triggers

===== on <event>

Event can be the keyword `definition`

Absence of a trigger is equivalent to `on definition`:

[code,kim]
----
example
----

===== over <extent>

==== Actions

===== set [target] to <expression>

===== integrate [target] to <expression>

===== do <expression>

==== Expressions

NOTE: need specific section for the language

=== Contextualizers

=== Scale constraints and how to influence them

=== Value constraints: units and extensive/intensive nature

=== Non-semantic models

=== Learning models

=== Documenting models

NOTE: subsection!

[#section-kim-defines]
== Definitions

Mixed content