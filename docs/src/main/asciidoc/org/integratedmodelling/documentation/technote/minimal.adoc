= k.LAB: a semantic web platform for integrated science.
Technical note, Jan 2021
Ferdinando Villa, Ph.D.

You use k.LAB to make observations, using the resources and the models available on the k.LAB network. To do that, you need a _client_ which connects to the network using a _certificate_. You can get both at ... The simplest way is connecting to an online k.Explorer instance and entering your credentials - it is also possible to set up an online client to not require credentials. From there, you can set your context and enter queries in the form of concepts to observe. As k.Explorer is also an application environment, you can choose one of a growing set of applications to explore a particular problem area in a more guided way.

# Architecture

Layers
Software stack (diagram)


# Resources

Resource layer provides a uniform way to refer to data and models that are not semantically enabled - I like to think of the resource layer as the black and white world of knowledge, as opposed to the semantics layer where you'll give meaning - "colors" - to them. The knowledge in the resource layer is by no means unsophisticated, as the resource layer is expected to be able to bridge to both data (of all kinds: spatial, tabular, temporal, from databases, files, services) and computations (which require inputs and provide outputs). This is achieved through the use of extensible _adapters_, which are extensible software plugins that bridge data formats or computational APIs to a common, k.LAB-compatible representation. We don't introduce all the adapters in this short guide: suffice it to say, for now, that there are adapters for many of the ways knowledge comes in, from spatial vector maps and Excel files to relational databases and machine-learned classifiers, and that the adapter API can be used to provide adapters for what isn't already available.

A resource in k.LAB is identified by a Unique Reference Name (URN) which can sometimes take simpler forms for convenience. The resource life cycle typically starts with an import action in the k.LAB Modeler, the software we distribute for creators of content, and after validation and initial curation continues with publication to a k.LAB site, which also includes setting the resource permissions, public or only available to specific users or user groups. From that point on, the URN can be used in a k.LAB semantic model by any user who has access to the network. After the resource is ingested, no trace of the specific type of resource remains or is visible from the URN. The use of the URN is uniform within the k.LAB environment irrespective of the original data format or type.  Besides the URN, each resource, once ingested and validated, exposes a _geometry_ (which relates to the representation of time, space or any other topology, and explains multiple values produced by it - the simplest geometry is the _scalar_ geometry for a single value) and a _type_ - the latter simply the type of the data it produces, e.g. number or text, and not the semantic type that is the job of the semantic layer to handle. Provenance information, metadata and permissions are also provided with resources. The conventions of the resource layer are aligned with current Linked Open Data (LOD) practices, in an effort to be a well-behaved citizen of the modern data world.


# Semantics and the k.IM language

k.LAB is an AI-driven technology to make scientific observations. It turns out that you cannot have a model make an observation unless you have first _stated_ explicitly what your "first", overall observation is - the _context_ for any subsequent observation. In order to observe, for example, atmospheric temperature you have to first specify where and when. So a first observation is necessary, which will typically define time and space boundaries and a "root" semantics for what your context is - e.g. a country, a governmental institution, a ship or a human body. While subsequent observations are computed, the first one is simply _acknowledged_ by the user, and that is a key principle of semantic modeling: all possible observations are relative to a first one that isn't computed through modeling but simply assumed to exist, and sets the context (and, importantly, the _scale_) for all the others. In our current k.LAB clients, which are optimized for earth observation applications and mostly use geographical objects as root contexts, we facilitate setting a context through intuitive user interface actions, such as zooming and panning a world map. If you need to define your root observation programmatically, the `observe` k.LAB statement [LINK] is there to help.

Observations "incarnate" a concept that is comparable to a logical query: e.g. .... But not all concepts are created equal, and different classes of concepts will create radically different scientific artifacts as their observation. Modeling in k.IM is essentially pairing resource URNs with logical statement and processing calls that enable observations of specific concepts to be made. Different classes of concepts lead to different statements, which lead to different results aligned with the different _meanings_ of the concepts they observe. These concept and observation classes are the key to using k.IM and k.LAB proficiently, and form the semantic space that enables deep integration within the k.LAB ecosystem.

Main classes and their distribution along the axis of occurrent/continuant and countable/non-countable. According to semantics, observations happen temporally/non-temporally (implying a scheduling or not, re: occurrent/continuant scope of computation) and require instantiator or resolver models. What is instantiated is resolved after instantiation, when it "exists" in the k.LAB actor space.

# The reactivity layer and the k.Actors language
