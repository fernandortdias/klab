= k.LAB resources handling
A field guide to the lifecycle of resources in k.LAB's and their adapters.
v1.0, 2021-02-18
:doctype: article
:description: Chat about resources handling with Villa
:kl: k.LAB
:kmod: k.Modeler
:kact: k.Actors
:keng: k.LAB Engine
:knod: k.LAB Node
:kim: k.IM
:ked: k.LAB Resourced Editor
:pex: Project Explorer
:encoding: utf-8
:lang: en
:title-page:
:toc: left
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:numbered:
:experimental:
:reproducible:
:icons: font
:listing-caption: Listing
:sectnums:
:autofit-option:
:mdash: &#8212;
:language: asciidoc
ifdef::backend-pdf[]
:title-logo-image: image:imgs/KLAB_LOGO.png[align=center]
:source-highlighter: rouge
//:rouge-style: github
//:source-highlighter: pygments
//:pygments-style: tango
endif::[]
:stem:

<<<


== Introduction

The **Resources layer** is the bottom layer of {kl}, in which we find what most novice users would identify as a resource: datasets or data services, devoid of any semantics beyond their conventional metadata. In {kl}, _computations_, from simple equations to complex models, can also live in the resources layer. In fact, anything that takes inputs and produces outputs can be seen as a {kl} resource. These inputs and outputs will be identified by a name and a type, for example numbers or textual categories. Imagine this as a black & white world, where products of scientific research live.

The aim of the resources layer is offering a common interface for k.LAB to access and manage pre-existing data, models and services of all kinds, as a first level of interoperability. This is obtained by a simple, carefully designed API, and through the use of _adapters_, i.e. software plug-ins that adapt a specific data or service format to it. Adapters are made available as {kl} _components_, installable in {keng}s and {knod}s, and can be extended by developers using the Java API to support formats and services not yet available.

In the _semantic_ layer of {kl}, resources are coupled with concepts, creating an _integrated_ world of knowledge that the resources layer alone can't provide. This is where the world gets its _meaning_ - its colors! - and where integration becomes possible. In the resources layer, knowledge is only identified by names and basic types, such as numeric, textual, or boolean.

This document looks at resources handling in a learn-by-example fashion from two different angles:

* the _modeler_ perspective: using {kmod} to create, modify, test, access or delete resources;
* the _developer_ perspective: the Java API and classes used to manage resources in the {keng}.

This document assumes that the reader is already acquainted with {kmod}'s user interface and its {kl} perspective.

=== Example project

In the following sections an example project named **im.docexample** is used, which has been created using the default parameters of the project creation wizard.

Each {kl} project contains a resources node in its tree:

image::imgs/01_resources_tree.png[scaledwidth=40%, width=40%, align="center"]

Adding a file resource (ex. an ESRI shapefile, CSV file, or geotiff raster coverage) is as simple as dragging a file from the filesystem explorer to the resources node.

Let's for example add a https://www.naturalearthdata.com/[Natural Earth] world shapefile to the example resources by dragging it onto the Resources tree node. The resource is instantly imported and appears in the tree:

image::imgs/02_resources_tree.png[scaledwidth=60%, width=60%, align="center"]

The import process performs a number of validation steps to assure that the resource can be used inside {kl}. In this case, the projection and other attributes are checked for conformance with accepted conventions and the shapes are validated. In general, {kl} adapters are intentionally strict, and won't accept files that are partially or badly specified: all information is needed in order for resources to be adaptable to all context of use.

== The Resource Editor

{kmod} features a **Resource Editor** that allows the user to manage supported resource types. When selecting a resource previously imported into the resources tree, the editor opens, showing three tabs, the default one being the Resource data tab:

image::imgs/03_resource_editor.png[scaledwidth=70%, width=70%, align="center"]

If the validation procedure had produced errors, the _Publishable_ checkbox won't be ticked and the _Why not_ textfield will describe the reason.

[NOTE]
====
Importing for example a multi-band imagery geotiff raster the same way as done with the shapefile, the editor reports an issue, and the URN is coloured red:

image::imgs/04_import_error.png[scaledwidth=100%, width=100%, align="center"]

It will be necessary to choose a band or provide a band mixer expression in the resource parameters to make the error go away and render the resource usable in a model.
====

The editor exposes important information about the resource:

* Its unique URN (Uniform Resource Name);
* Its attributes, if any exist;
* The geometry (space, time) and its textual encoding;
* All adapter attributes that define how {kl} will handle the resource.

Every resource also has a **data type.**, which describes the main output as, for example, numeric or textual. Because the type may change depending on the context of use, it is not shown in the editor. In the case of a shapefile the type is **OBJECT**, i.e. the resource, when applied to a context, will produce a set of objects, each of which will have its own independent geometry. In the case of a raster coverage, such as a geotiff or a WCS service, then the type would be **NUMBER**.

TIP: In the Java API, the possible types of a resource (also including many others that resources cannot produce) are defined in the `Type` enum which belongs to the `IArtifact` class. footnote:[org.integratedmodelling.klab.api.provenance.IArtifact - PROBABLY WE SHOULD HAVE MAVEN INSTALL JAVADOCS SOMEWHERE STABLE, AND LINK TO THAT INSTEAD]. 

=== Local and global URNs
[#REF_URNS]

Each resource can be identified as local or public. Upon creation the resource lives in a user project, and is therefore local. Modelers wishing to use that resource must have that project loaded in their engine's workspace. The name of a file-based local resource is derived from that of the original file: for example in case of a shapefile it is simply the file name without the path. The local name can be used as an identifier in place of the fully specified URN in {kim} models located the same project.
The URN (which can be copied to che clipboard by right clicking on the resource through _copy URN_) is the fully specified identifier and is the recommended way to reference resources in {kim} namespaces.


A URN consists of 4 parts, separated by colons:

* the **node name** (the name of the node where the resource was originally published);
* the **catalog** (a logical space handled by the node, for example a domain such as hydrology, or a name describing a large-scale collection of data);
* the **namespace** (a secondary logical space within the catalog);
* the **resource identifier**.

Dot-separated paths are normally used for each component of a URN, providing a further way to organize and document the origin and logical scope of a resource, using https://en.wikipedia.org/wiki/Reverse_domain_name_notation[reverse DNS notation] when appropriate. A clean URN should contain only lowercase identifiers and no other characters than ASCII letters or the underscore sign, although other characters are accepted.

When a resource is created locally, the four parts of the URN are used differently:

* instead of the node name, the string 'local' is used;
* instead of the catalog, the URN will contain the user name of the user that created it;
* instead of the namespace, the URN will contain the name of the project where the resource was created;
* the identifier will be built from the file name (if file based) or from user input.

A **local** resource's URN might for example look as follows:

----
local:moovida:im.docexample:ne_10m_admin_1_states_provinces
----

Once published, the URN of a resource will reflect the above described specification.

NOTE: One important note related to the node part in the URN: even if the resource will forever carry the originating node name in its URN, this doesn't mean that it can't be resolved by other nodes. {kl}'s mirroring API can be used to mirror resources to different nodes, to maximize the chance that a public resource is resolved even if some nodes are offline, and to support load balancing in the {kl} network for frequently used resources. 

There is a third type of resource, named universal resource (see <<REF_UNIVERSALRESOURCES, the dedicated section>>) that, due to its nature, follows a particular URN schema, identified by the **klab** prefix. 
If the URN starts with the keyword **klab**, then the meaning of the 4 pieces of the URN are the following:

* the keyword klab;
* the name of the adapter to use to resolve it;
* the namespace to specify the service requested to the adapter;
* the identifier of the specific resource.

For example, the following URN

----
klab:weather:stations:all
----

turns into a request to the `weather` adapter for the `stations` service, which returns weather station objects with their data, and requests all the stations in the context of resolution (as opposed to, e.g., only those of a certain category or technology). The weather adapter may be installed in the local engine (in which case no node is involved in satisfying the request) or provided by one or more nodes on the network. In the latter case, the node with the lightest load at the time of request will be chosen to honor it.

Detailed information about URN internals can be found in the section _<<REF_RESOURCEMANAGEMENT, about URNs and resources management>>_. 

=== Attributes
[#REF_ATTRIBUTES]

Depending on the type of resource, the object can have attributes, inputs or outputs. A shapefile based resource, which is of type OBJECT, has an attribute table:

image::imgs/05_attributes.png[scaledwidth=70%, width=70%, align="center"]

If instead the resource is a model, it will have the **inputs** and **outputs** tabs filled instead of attributes tab. 

[NOTE]
====
The attributes, inputs and outputs, that are defined by a name and type, are the connection piece between the resources and the semantic level. These can be referenced in the models using the attribute's name to create the connection to the concepts in the semantic world.
====


=== Geometry information

Under the map view in light gray, a small text describes the geometry of the resource. For the example shapefile it states:

----
#s2(4594){bbox=[-179.99999999999991 180.0 -89.99999999999994 83.63410065300008],proj=EPSG:4326}
----

Defining:

* a resource that contains several objects (defined by the presence of the **#**)
* irregular spatial bidimensional geometry (defined by the lowercase **s2**)
* the data bounding box
* the projection

=== Adapter attributes
[#REF_ADAPTERATTRIBUTES]

The adapter properties view lists the parameters of the currently used adapter. In the discussed test case the used adapter is the **VECTOR** adapter:

image::imgs/09_adapter_table.png[scaledwidth=80%, width=80%, align="center"]

One notable parameter is the filter parameter, which can be used to exclude part of the resource, if necessary. The procedure is as simple as inserting a CQL (https://docs.geoserver.org/latest/en/user/tutorials/cql/cql_tutorial.html[Common Query Language]) based on the object's attributes (ex. _adm1_code=SOMECODE_).

=== Publishing a resource

Resources are created at first as local and can be used inside the project that contains them. The obvious lifecycle of a resource is to be published and made available across nodes that are interested in exposing it. 

The publish button in the {ked} helps the user in the publishing process with a dedicated wizard:

image::imgs/10_publish_dialog.png[scaledwidth=70%, width=70%, align="center"]

[CAUTION]
====
Publishing is the moment in which the user will need to have very clear ideas about the resource and its whereabouts. **Once published, a resource should not be changed** anymore, since changes in existing resources might break models that depend on them.

In future {kl} will feature a peer review procedure to add a level of control to the resources publishing workflow.
====

The publishing dialog also allows to choose finer granularity for resource permissions. By default a resource is visible only to the user that created it. The _Publish_ checkbox allows to make it globally visible. Finally, it is possible to make resources visible only to certain users and groups (comma separated list) or exclude groups/users.

Before publishing, the metadata tab should be filled in with relevant metadata:

image::imgs/11_publish_metadata.png[scaledwidth=80%, width=80%, align="center"]

WARNING: Many users believe that information such as time and spatial context are part of the metadata. This is bad practice since they are part of the semantic and have their own place in {kl}.


== Adding resources 

In cases in which the resource is not file based and drag'n'drop can't be exploited, the _new resource_ wizard can be launched by right clicking on the resources node and selecting the **New resource...** action. The wizard allows to define an id for the resource and select one fo the possible adapter types:

image::imgs/06_new_resource.png[scaledwidth=80%, width=80%, align="center"]

Once the adapter has been chosen, its parameters need to be defined. The following image shows the example of the mandatory (red) and optional parameters of a WFS adapter:

image::imgs/07_new_resource_wfs.png[scaledwidth=80%, width=80%, align="center"]

In the image it is quite clear what the URN of the new resource will look like (Resource ID at the top) and how for the local resource the user selects only the last piece of the URN, the resource identifier.

=== Behind the scenes

How things are handled behind the scenes can be understood when leaving the safety of the {kl} perspective by switching to the **{pex}** perspective:

image::imgs/08_project_explorer.png[scaledwidth=80%, width=80%, align="center"]

While the {kl} prespective shows a logical view of the resources, the {pex} presents a physical view of the resources, as they are persisted on the storage.

CAUTION: File based resources are copied in the resources folder when imported, being it few bytes or many gigabytes. The user should be aware of ramifications when importing datasets.

Looking into the **resources** folder we will find a folder for each created resource. Each resource also presents a **resource.json** file, which contains all information {kl} needs to know about. The resource json file is text based and it is simple to read the basic information from it and see where they are used in the {ked} user interface:

[source,json,linenums]
----
{
  "urn" : "local:moovida:im.docexample:ne_10m_admin_1_states_provinces",
  "version" : "0.0.1",
  "adapterType" : "vector",
  "localPath" : "im.docexample/resources/ne_10m_admin_1_states_provinces.v0.0.1",
  "geometry" : "#s2(4594){bbox=[-179.99999999999991 180.0 -89.99999999999994 83.63410065300008],proj=EPSG:4326}",
  "projectName" : "im.docexample",
  "localName" : "ne_10m_admin_1_states_provinces.shp",
  "type" : "OBJECT",
  "resourceTimestamp" : 1613125478144,
  "metadata" : {
    "im:keywords" : "features,ne_10m_admin_1_states_provinces",
    "dc:title" : "ne_10m_admin_1_states_provinces"
  },
  "parameters" : { },
  "localPaths" : [ "im.docexample/resources/ne_10m_admin_1_states_provinces.v0.0.1/ne_10m_admin_1_states_provinces.shx", "im.docexample/resources/ne_10m_admin_1_states_provinces.v0.0.1/ne_10m_admin_1_states_provinces.dbf", "im.docexample/resources/ne_10m_admin_1_states_provinces.v0.0.1/ne_10m_admin_1_states_provinces.prj", "im.docexample/resources/ne_10m_admin_1_states_provinces.v0.0.1/ne_10m_admin_1_states_provinces.shp" ],
  "history" : [ ],
  "notifications" : [ ],
  "attributes" : [ {
    "name" : "featurecla",
    "type" : "TEXT",
    "key" : false,
    "optional" : true,
    "exampleValue" : null,
    "index" : 0
  }, 
  ...
  
  ...
  
  ...
  {
    "name" : "ne_id",
    "type" : "NUMBER",
    "key" : false,
    "optional" : true,
    "exampleValue" : null,
    "index" : 0
  } ],
  "spatialExtent" : {
    "east" : 180.0,
    "west" : -179.99999999999991,
    "north" : 83.63410065300008,
    "south" : -89.99999999999994,
    "gridResolution" : null,
    "gridUnit" : null
  },
  "dependencies" : null,
  "outputs" : null,
  "exportFormats" : {
    "shp" : "ESRI shapefile"
  }
}

----

== Finding resources

To help users to find resources when writing models, the {kmod} offers a resources finder view:

image::imgs/12_resources_view.png[scaledwidth=80%, width=80%, align="center"]

On entering keywords in the search field, the view presents resouces that match the text. 

On double clicking on the resource, it is opened in the {ked} while with a simple right click it is possible to get the URN to use inside the scripts.

The upper right combobox allows to set the filer on looking for the resource locally or on public nodes.

WARNING: At the moment the search API for nodes is not implemented, therefore the public search is not yet usable.



== Looking at the source code
[#REF_RESOURCEMANAGEMENT]

The following sections present the developer perspective of what has been seen in the previous chapters. Notable code passages are used to explain the information flow and processes behind the {keng} and {kmod}.

=== URNs

URNs are handled in the class **Urns**footnote:[org.integratedmodelling.klab.common.Urns].

The class is basically and utility class that allows the developer to manage URNs.

One important information developers should be aware of, is the one expressed by the first attributes of the class:

[source,java,linenums]
----
	final public static String KLAB_URN_PREFIX = "urn:klab:";
	final public static String LOCAL_URN_PREFIX = "urn:klab:local:";
	final public static String VOID_URN_PREFIX = "urn:klab:void:";
	final public static String LOCAL_FILE_PREFIX = "file:";
----

{kl} URNs are build following offical URN Specifications. As such all {kl} URNs begin with the **urn:klab** prefix. It is only to enhance readability that inside the {kim} and {kact} editors shortcuts omitting the prefix can be used.

Another information that the URN class (in conjunction with the Resources class, explained later) makes clear are the tree levels of URN visibility:

* local
* global
* universal

=== Resolving URNs to resources

URN resolution is handled inside the singleton **Resources**footnote:[org.integratedmodelling.klab.Resources].

While the instance of Resources can be accessed directly, it is a service (IResourceService) and as such it can be accessed throughout the system also from components that do not have directly imported the package of the implementation.

[source,java]
----
IResourceService service = Services.INSTANCE.getService(IResourceService.class)
----

Resource resolution is done by passing the URN to the **resolveResource** method. If the URN can be properly resolved, an IResource object is returned. 

=== IResources

In the IResource interface we find farious methods, whose functionality can be tracked back to the {ked} user interface (this should now sound obvious, since it represents the resource object). The methods are quite selfexplicatory and have a javadoc that describes them. Some of these are worth to be described for better understanding without the need to access the source code:

* _getDependencies()_: resources can depend on other resources. If that is the case, the method will return a list of the URNs of said dependencies.
* _getGeometry()_: the resource's geometry. Geometries are quite complex in {kl} and can cover different extents (also time, not just space) and have different dimensions. Interested developers should head to the javadoc of the IGeometry interface to dive in the internals of geometries. It is important to understand that the scale (**IScale**footnote:[org.integratedmodelling.klab.api.observations.scale.IScale]) is the semantic version of the geometry. As such it is possible to create a scale from a geometry or vice versa. It is in the scale where the geometry finds a place in which space and time are understood through semantics, while at mere IGeometry level it represents a topologhy and that's it.
* _getVersion()_: each resource has a versioning system. Local resources don't obey to said system. But once a resource is published, a version 0.0.1 is attributed to it. At every change a version update is done. 
* _getHistory()_: each resource also contains a list of its history. The list contains all resources the current resource transitioned through in history, each with its own version.
* _getParameters()_: a resource can have parameters. Part of them can be created by the adapter that took care of a resource (the ones seen in section about <<REF_ADAPTERATTRIBUTES, adapter attributes>>). 
*  _getAttributes(), getInputs(), getOutputs()_: resources that produce objects can have a set of attributes, modeling resources can have inputs and outputs. These are visualized in the {ked} as shown in the <<REF_ATTRIBUTES, attributes>> section.
* _getAdapterType()_: the adapter type that is in charge of the resource.

It is important to note that resource objects are mandatorily created using the resource builderfootnote:[org.integratedmodelling.klab.api.data.IResource.Builder].

=== The resource adapter

Once a resource is imported into {kmod}  (for example dragging a file onto the resources node) the **importResource** method ot the resource service is called.

The first step in there is the choice of the adapter (**IResourceAdapter**) that can handle the resource:

[source,java,linenums]
----
IResourceAdapter adapter = null;
if (adapterType == null) {
    List<IResourceAdapter> adapters = getResourceAdapter(file, parameters);
    if (adapters.size() > 0) {
        adapter = adapters.get(0);
        adapterType = adapter.getName();
    }
} else {
    adapter = resourceAdapters.get(adapterType).adapter;
}
----

Once the adapter is defined, a set of tooling objects are made available through its API: a validator, an encoder, a publisher. To create a new resource adapter it is necessary to create an object that implements the IResourceAdapter interface but also its subobjects, as IResourceValidator, IResourcePublisher and IResourceEncoder.

The adapters are discovered by the system from their annotation (ex. in the raster adapter):

[source,java,linenums]
----
@ResourceAdapter(type = "raster", version = Version.CURRENT, 
    requires = { "fileUrl" },
    optional = { "band", "interpolation", "nodata", "bandmixer" }, 
    canCreateEmpty = false, handlesFiles = true)
public class RasterAdapter implements IResourceAdapter {
 //   ...
}
----

The IResourceValidator interface guides the developer in the implementation of the main validator functionalities:

* canHandle: the first and fastest check that defines if the adapted is able to handle the given resource.
* validate: implements the validation logic starting from a URL and userdata. Successfull validation results in returning a builder object used to then create the resource.
* update: a method that allows the resource to be saved as the result of user changes
* performOperation: if the resource allows to perform operations on the resource, it should be implemented. Operations are then made available to the user in the {ked} in the combobox below the <<REF_ATTRIBUTES, attributes table>>.

The **RasterValidator** class is a good startig point for developers that want to understand how the resource is created using the builder object. In the validate methods it is simple to track how spatial extent is defined, the projection is set or for example the geometry is defined:

[source,java,linenums]
----
Geometry geometry = Geometry.create("S2")
    .withBoundingBox(
        envelope.getMinimum(0), 
        envelope.getMaximum(0), 
        envelope.getMinimum(1),
        envelope.getMaximum(1)
    )
    .withProjection(crsCode)
    .withSpatialShape(
        (long) grid.getGridRange().getSpan(0), 
        (long) grid.getGridRange().getSpan(1)
    );
builderObj.withGeometry(geometry);
----

=== Universal resources
[#REF_UNIVERSALRESOURCES]

In the <<REF_URNS,section about URNs>> local and global URNs have been discussed and a third type of resource has been introduced: universal resources.

A universal resource is basically a service. It is not created on top of a particular node and hence doesn't base on the availability of a particular node (even if nodes can be configured to accept such a resource or not). It is created implementing the universal protocol using the **IUrnAdapter** interface. One example is the **RandomAdapter**footnote:[org.integratedmodelling.random.adapters.RandomAdapter] that is able to handle URNs that start with: **klab:random:...**.

Basically universal resources can be accessed using the **klab:...** prefix. This means that there is one reserved node named klab and it can be used to address universal resources.

The weather adapterfootnote:[org.integratedmodelling.weather.adapters.WeatherAdapter] is probably the most important example of universal resource. It was created as such mainly because it is a resource that is handled internally in the {kl} system and does not come directly from external sources. That is due to the fact that a lot of preprocessing needs to be done to address data validation as well as synchronization with several datasources (ex. NOAA) needs to occurr. The data are then saved in an internal database and made available as internal service. The {kl} weather resource can be accessed through the **klab:weather:...** prefix.

Universal klab resources can be served by different nodes the same way as it happens for other global resources. It is clear that while a random adapter resource - being very simple - can be run from any node, a weather adapter that would take days only to build the initial database will be accepted only on dedicated nodes. For that exacty reason only one node, **im.weather**, currently handles _klab:weather_ resources.

=== Contextualizing a resource

When a resource need to be contextualized, the **getResourceData** method of the **Resources** class is used.

There are various versions of the method that allow to iterate over the resource using a given scale (i.e. defined steps in sapce and time) or to simply iterate over the whole resource without a particular notion of scale.

[CAUTION]
====
At the current time the IResourceService doesn't provide the getResourceData methods, but might soon do that to expose them also in the service object. 

This can be particularly useful for components that do not have access to the engine, but need to validate other resources they concurr with.
====

The first step towards contextualization is to check whether the resource is local, global or universal. 

After a first simple URN check the resource is investigated on being local, global or universal (in which case it could still be local, since the universal resource could reside on the local node):

[source,java,linenums]
----
boolean local = Urns.INSTANCE.isLocal(resource.getUrn());

...

if (urn.isUniversal()) {
    local = getUrnAdapter(urn.getCatalog()) != null;
}
----

If it is local but also universal, then the adapter is retrieved directly from the catalog and used to build the data object (IKlabData):

[source,java,linenums]
----
IUrnAdapter adapter = getUrnAdapter(urn.getCatalog());
...
IKlabData.Builder builder = new LocalDataBuilder((IRuntimeScope) context);

...

adapter.getEncodedData(urn, builder, geometry, context);
IKlabData ret = builder.build();
----

If the resource is not local, then the workflow is uniform for global and universal resources, starting by finding the node, choosing the one with less load between the ones available. Then a REST request is prepared and sent to the node using a builder that creates the data that are retrieved from the resource:

[source,java,linenums]
----
INodeIdentity node = Network.INSTANCE.getNodeForResource(urn);

...

DecodingDataBuilder builder = new DecodingDataBuilder(
        node.getClient().post(API.NODE.RESOURCE.CONTEXTUALIZE, request, Map.class), context);
IKlabData ret = builder.build();
----


Generally speaking, if the resource is local, a **LocalDataBuilder** is used and passed to the encoder of the adapter. The encoder is the component that takes the resource and the scale and fills in all the necessary pieces of the data builder:

[source,java,linenums]
----
IResourceAdapter adapter = getResourceAdapter(resource.getAdapterType());

...

IKlabData.Builder builder = new LocalDataBuilder(context);
adapter.getEncoder().getEncodedData(resource, urnParameters, geometry, builder, context);
IKlabData ret = builder.build();
----


[NOTE]
====
If the case of a raster resource for example the encoder would take the geometry and create a subset, reproject and apply any necessary transform, then it would extract each x/y cell and pass them to the builder. Once the build method is called a **non-semantic** artifact is created. 

The non-semantic artifact, depending on the used builder, could be promoted to the semantic world. For example, when a model is run, the context passed to the LocalDataBuilder could provide an empty state (IState). The builder would then add information of the artifact to the state.
====

If instead the resource is public (aka global), a **DecodingDataBuilder** is used. It basically followes the same logic as the local builder, but using network protocols to retrieve the necessary pieces (using https://en.wikipedia.org/wiki/Protocol_Buffers[protobuf] for the serialization).

[source,java,linenums]
----
DecodingDataBuilder builder = new DecodingDataBuilder(
        node.getClient().post(API.NODE.RESOURCE.CONTEXTUALIZE, request, Map.class), context);
IKlabData ret = builder.build();
----

== Links, footnotes and resources

=== Footnotes

