/*
 * generated by Xtext 2.18.0
 */
package org.integratedmodelling.kactors.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.integratedmodelling.kactors.kactors.Actions;
import org.integratedmodelling.kactors.kactors.ActorInstantiation;
import org.integratedmodelling.kactors.kactors.Annotation;
import org.integratedmodelling.kactors.kactors.ArgumentDeclaration;
import org.integratedmodelling.kactors.kactors.Assignment;
import org.integratedmodelling.kactors.kactors.Classifier;
import org.integratedmodelling.kactors.kactors.Concept;
import org.integratedmodelling.kactors.kactors.ConceptDeclaration;
import org.integratedmodelling.kactors.kactors.Constructor;
import org.integratedmodelling.kactors.kactors.Currency;
import org.integratedmodelling.kactors.kactors.Date;
import org.integratedmodelling.kactors.kactors.Definition;
import org.integratedmodelling.kactors.kactors.DoStatement;
import org.integratedmodelling.kactors.kactors.ElseIfStatementBody;
import org.integratedmodelling.kactors.kactors.ForStatement;
import org.integratedmodelling.kactors.kactors.HeaderRow;
import org.integratedmodelling.kactors.kactors.IfStatement;
import org.integratedmodelling.kactors.kactors.KactorsPackage;
import org.integratedmodelling.kactors.kactors.KeyValuePair;
import org.integratedmodelling.kactors.kactors.List;
import org.integratedmodelling.kactors.kactors.ListElement;
import org.integratedmodelling.kactors.kactors.Literal;
import org.integratedmodelling.kactors.kactors.LookupTable;
import org.integratedmodelling.kactors.kactors.Map;
import org.integratedmodelling.kactors.kactors.MapEntry;
import org.integratedmodelling.kactors.kactors.Match;
import org.integratedmodelling.kactors.kactors.MessageBody;
import org.integratedmodelling.kactors.kactors.MessageCall;
import org.integratedmodelling.kactors.kactors.Metadata;
import org.integratedmodelling.kactors.kactors.MetadataPair;
import org.integratedmodelling.kactors.kactors.Model;
import org.integratedmodelling.kactors.kactors.Observable;
import org.integratedmodelling.kactors.kactors.ObservableSemantics;
import org.integratedmodelling.kactors.kactors.ParameterList;
import org.integratedmodelling.kactors.kactors.Preamble;
import org.integratedmodelling.kactors.kactors.Quantity;
import org.integratedmodelling.kactors.kactors.REL_OPERATOR;
import org.integratedmodelling.kactors.kactors.Statement;
import org.integratedmodelling.kactors.kactors.StatementBody;
import org.integratedmodelling.kactors.kactors.StatementGroup;
import org.integratedmodelling.kactors.kactors.StatementList;
import org.integratedmodelling.kactors.kactors.Table;
import org.integratedmodelling.kactors.kactors.TableClassifier;
import org.integratedmodelling.kactors.kactors.TableRow;
import org.integratedmodelling.kactors.kactors.Tree;
import org.integratedmodelling.kactors.kactors.Unit;
import org.integratedmodelling.kactors.kactors.UnitElement;
import org.integratedmodelling.kactors.kactors.Value;
import org.integratedmodelling.kactors.kactors.ValueOperator;
import org.integratedmodelling.kactors.kactors.WhileStatement;
import org.integratedmodelling.kactors.services.KactorsGrammarAccess;

@SuppressWarnings("all")
public class KactorsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KactorsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KactorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KactorsPackage.ACTIONS:
				sequence_Actions(context, (Actions) semanticObject); 
				return; 
			case KactorsPackage.ACTOR_INSTANTIATION:
				sequence_ActorInstantiation(context, (ActorInstantiation) semanticObject); 
				return; 
			case KactorsPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case KactorsPackage.ARGUMENT_DECLARATION:
				sequence_ArgumentDeclaration(context, (ArgumentDeclaration) semanticObject); 
				return; 
			case KactorsPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case KactorsPackage.CLASSIFIER:
				sequence_Classifier(context, (Classifier) semanticObject); 
				return; 
			case KactorsPackage.CONCEPT:
				sequence_Concept(context, (Concept) semanticObject); 
				return; 
			case KactorsPackage.CONCEPT_DECLARATION:
				if (rule == grammarAccess.getConceptDeclarationRule()) {
					sequence_ConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFactorRule()) {
					sequence_ConceptDeclaration_Factor(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getTermRule()) {
					sequence_ConceptDeclaration_Factor_Term(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleConceptDeclarationRule()) {
					sequence_SimpleConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else break;
			case KactorsPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case KactorsPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case KactorsPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case KactorsPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case KactorsPackage.DO_STATEMENT:
				sequence_DoStatement(context, (DoStatement) semanticObject); 
				return; 
			case KactorsPackage.ELSE_IF_STATEMENT_BODY:
				sequence_ElseIfStatementBody(context, (ElseIfStatementBody) semanticObject); 
				return; 
			case KactorsPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case KactorsPackage.HEADER_ROW:
				sequence_HeaderRow(context, (HeaderRow) semanticObject); 
				return; 
			case KactorsPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case KactorsPackage.KEY_VALUE_PAIR:
				sequence_KeyValuePair(context, (KeyValuePair) semanticObject); 
				return; 
			case KactorsPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case KactorsPackage.LIST_ELEMENT:
				sequence_ListElement(context, (ListElement) semanticObject); 
				return; 
			case KactorsPackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case KactorsPackage.LOOKUP_TABLE:
				sequence_LookupTable(context, (LookupTable) semanticObject); 
				return; 
			case KactorsPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case KactorsPackage.MAP_ENTRY:
				sequence_MapEntry(context, (MapEntry) semanticObject); 
				return; 
			case KactorsPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case KactorsPackage.MESSAGE_BODY:
				sequence_MessageBody(context, (MessageBody) semanticObject); 
				return; 
			case KactorsPackage.MESSAGE_CALL:
				sequence_MessageCall(context, (MessageCall) semanticObject); 
				return; 
			case KactorsPackage.METADATA:
				sequence_Metadata(context, (Metadata) semanticObject); 
				return; 
			case KactorsPackage.METADATA_PAIR:
				sequence_MetadataPair(context, (MetadataPair) semanticObject); 
				return; 
			case KactorsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KactorsPackage.NUMBER:
				sequence_Number(context, (org.integratedmodelling.kactors.kactors.Number) semanticObject); 
				return; 
			case KactorsPackage.OBSERVABLE:
				sequence_Observable(context, (Observable) semanticObject); 
				return; 
			case KactorsPackage.OBSERVABLE_SEMANTICS:
				sequence_ObservableSemantics(context, (ObservableSemantics) semanticObject); 
				return; 
			case KactorsPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case KactorsPackage.PREAMBLE:
				sequence_Preamble(context, (Preamble) semanticObject); 
				return; 
			case KactorsPackage.QUANTITY:
				sequence_Quantity(context, (Quantity) semanticObject); 
				return; 
			case KactorsPackage.REL_OPERATOR:
				sequence_REL_OPERATOR(context, (REL_OPERATOR) semanticObject); 
				return; 
			case KactorsPackage.STATEMENT:
				if (rule == grammarAccess.getNextStatementRule()) {
					sequence_NextStatement(context, (Statement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Statement(context, (Statement) semanticObject); 
					return; 
				}
				else break;
			case KactorsPackage.STATEMENT_BODY:
				sequence_StatementBody(context, (StatementBody) semanticObject); 
				return; 
			case KactorsPackage.STATEMENT_GROUP:
				sequence_StatementGroup(context, (StatementGroup) semanticObject); 
				return; 
			case KactorsPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case KactorsPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case KactorsPackage.TABLE_CLASSIFIER:
				sequence_TableClassifier(context, (TableClassifier) semanticObject); 
				return; 
			case KactorsPackage.TABLE_ROW:
				sequence_TableRow(context, (TableRow) semanticObject); 
				return; 
			case KactorsPackage.TREE:
				sequence_Tree(context, (Tree) semanticObject); 
				return; 
			case KactorsPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case KactorsPackage.UNIT_ELEMENT:
				sequence_UnitElement(context, (UnitElement) semanticObject); 
				return; 
			case KactorsPackage.VALUE:
				if (rule == grammarAccess.getValueWithConstructorRule()) {
					sequence_ValueWithConstructor(context, (Value) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueWithMetadataWithoutTreeRule()) {
					sequence_ValueWithMetadataWithoutTree(context, (Value) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueWithMetadataRule()) {
					sequence_ValueWithMetadata(context, (Value) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueRule()) {
					sequence_Value(context, (Value) semanticObject); 
					return; 
				}
				else break;
			case KactorsPackage.VALUE_OPERATOR:
				sequence_ValueOperator(context, (ValueOperator) semanticObject); 
				return; 
			case KactorsPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Actions returns Actions
	 *
	 * Constraint:
	 *     (match=Match | (matches+=Match matches+=Match*) | statement=Statement | statements=StatementList)
	 */
	protected void sequence_Actions(ISerializationContext context, Actions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActorInstantiation returns ActorInstantiation
	 *
	 * Constraint:
	 *     (behavior=PathName parameters=ParameterList? actions=Actions? metadata=Metadata?)
	 */
	protected void sequence_ActorInstantiation(ISerializationContext context, ActorInstantiation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (name=ANNOTATION_ID parameters=ParameterList?)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentDeclaration returns ArgumentDeclaration
	 *
	 * Constraint:
	 *     (ids+=LOWERCASE_ID ids+=LOWERCASE_ID*)?
	 */
	protected void sequence_ArgumentDeclaration(ISerializationContext context, ArgumentDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (recipient=LOWERCASE_ID? variable=LOWERCASE_ID value=ValueWithConstructor)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classifier returns Classifier
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         observable=Observable | 
	 *         id=LOWERCASE_ID | 
	 *         id=LOWERCASE_ID_DASH | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         map=Map | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_Classifier(ISerializationContext context, Classifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptDeclaration returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             (
	 *                 compresent=SimpleConceptDeclaration | 
	 *                 causant=SimpleConceptDeclaration | 
	 *                 adjacent=SimpleConceptDeclaration | 
	 *                 container=SimpleConceptDeclaration | 
	 *                 contained=SimpleConceptDeclaration | 
	 *                 caused=SimpleConceptDeclaration
	 *             )? 
	 *             (distributedOfInherency?='each'? inherency=SimpleConceptDeclaration)? 
	 *             (distributedForInherency?='each'? motivation=SimpleConceptDeclaration)? 
	 *             (distributedTemporalInherency?='each'? during=SimpleConceptDeclaration)? 
	 *             (distributedWithinInherency?='each'? context=SimpleConceptDeclaration)? 
	 *             (relationshipSource=SimpleConceptDeclaration relationshipTarget=SimpleConceptDeclaration)?
	 *         )+
	 *     )
	 */
	protected void sequence_ConceptDeclaration(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Factor returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             (
	 *                 compresent=SimpleConceptDeclaration | 
	 *                 causant=SimpleConceptDeclaration | 
	 *                 adjacent=SimpleConceptDeclaration | 
	 *                 container=SimpleConceptDeclaration | 
	 *                 contained=SimpleConceptDeclaration | 
	 *                 caused=SimpleConceptDeclaration
	 *             )? 
	 *             (distributedForInherency?='each'? motivation=SimpleConceptDeclaration)? 
	 *             (distributedWithinInherency?='each'? context=SimpleConceptDeclaration)? 
	 *             (relationshipSource=SimpleConceptDeclaration relationshipTarget=SimpleConceptDeclaration)? 
	 *             (distributedTemporalInherency?='each'? during=SimpleConceptDeclaration)? 
	 *             (distributedOfInherency?='each'? inherency=SimpleConceptDeclaration)?
	 *         )+ 
	 *         ((operators+='and' | operators+='follows') operands+=Term)*
	 *     )
	 */
	protected void sequence_ConceptDeclaration_Factor(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ConceptDeclaration
	 *     Term returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             (
	 *                 compresent=SimpleConceptDeclaration | 
	 *                 causant=SimpleConceptDeclaration | 
	 *                 adjacent=SimpleConceptDeclaration | 
	 *                 container=SimpleConceptDeclaration | 
	 *                 contained=SimpleConceptDeclaration | 
	 *                 caused=SimpleConceptDeclaration
	 *             )? 
	 *             (distributedForInherency?='each'? motivation=SimpleConceptDeclaration)? 
	 *             (distributedWithinInherency?='each'? context=SimpleConceptDeclaration)? 
	 *             (relationshipSource=SimpleConceptDeclaration relationshipTarget=SimpleConceptDeclaration)? 
	 *             (distributedTemporalInherency?='each'? during=SimpleConceptDeclaration)? 
	 *             (distributedOfInherency?='each'? inherency=SimpleConceptDeclaration)?
	 *         )+ 
	 *         ((operators+='and' | operators+='follows') operands+=Term)* 
	 *         (operators+='or' operands+=Factor)*
	 *     )
	 */
	protected void sequence_ConceptDeclaration_Factor_Term(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns Concept
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (negated?='not' | negated?='no')? 
	 *             name=NamespaceId 
	 *             (
	 *                 authConcept?='identified' 
	 *                 (stringIdentifier=ID | stringIdentifier=STRING | stringIdentifier=UPPERCASE_ID | stringIdentifier=CAMELCASE_ID | intIdentifier=INT) 
	 *                 (authority=UPPERCASE_ID | authority=UPPERCASE_PATH)
	 *             )?
	 *         ) | 
	 *         (presence?='presence' concept=SimpleConceptDeclaration) | 
	 *         (count?='count' concept=SimpleConceptDeclaration) | 
	 *         (distance?='distance' concept=SimpleConceptDeclaration) | 
	 *         (probability?='probability' concept=SimpleConceptDeclaration) | 
	 *         (assessment?='assessment' concept=SimpleConceptDeclaration) | 
	 *         ((change?='in' | rate?='rate' | change?='changed') concept=SimpleConceptDeclaration) | 
	 *         (uncertainty?='uncertainty' concept=SimpleConceptDeclaration) | 
	 *         (magnitude?='magnitude' concept=SimpleConceptDeclaration) | 
	 *         (level?='level' concept=SimpleConceptDeclaration) | 
	 *         (type?='type' concept=SimpleConceptDeclaration) | 
	 *         (observability?='observability' concept=SimpleConceptDeclaration) | 
	 *         (proportion?='proportion' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (percentage?='percentage' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (ratio?='ratio' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration) | 
	 *         (monetary?='monetary'? value?='value' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (occurrence?='occurrence' concept=SimpleConceptDeclaration) | 
	 *         (
	 *             authConcept?='identity' 
	 *             (stringIdentifier=ID | stringIdentifier=STRING | stringIdentifier=UPPERCASE_ID | stringIdentifier=CAMELCASE_ID | intIdentifier=INT) 
	 *             (authority=UPPERCASE_ID | authority=UPPERCASE_PATH)
	 *         ) | 
	 *         declaration=Expression
	 *     )
	 */
	protected void sequence_Concept(ISerializationContext context, Concept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     (path=QuotablePathName? classid=CAMELCASE_ID parameters=ParameterList?)
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Currency returns Currency
	 *
	 * Constraint:
	 *     (id=UPPERCASE_ID year=INT units+=UnitElement*)
	 */
	protected void sequence_Currency(ISerializationContext context, Currency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Date returns Date
	 *
	 * Constraint:
	 *     (year=INT bc?='BC'? month=INT day=INT (hour=INT min=INT (sec=INT ms=INT?)?)?)
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     (annotations+=Annotation* name=LOWERCASE_ID arguments=ArgumentDeclaration? body=MessageBody)
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DoStatement returns DoStatement
	 *
	 * Constraint:
	 *     (body=StatementBody expression=EXPR)
	 */
	protected void sequence_DoStatement(ISerializationContext context, DoStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.DO_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.DO_STATEMENT__BODY));
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.DO_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.DO_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoStatementAccess().getBodyStatementBodyParserRuleCall_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getDoStatementAccess().getExpressionEXPRTerminalRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElseIfStatementBody returns ElseIfStatementBody
	 *
	 * Constraint:
	 *     ((literal=Literal | expression=EXPR | variable=LOWERCASE_ID) body=StatementBody)
	 */
	protected void sequence_ElseIfStatementBody(ISerializationContext context, ElseIfStatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (id=LOWERCASE_ID? value=Value body=StatementBody)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderRow returns HeaderRow
	 *
	 * Constraint:
	 *     (
	 *         (elements+=LOWERCASE_ID | elements+=STRING | elements+=LOCALIZED_STRING_REFERENCE) 
	 *         elements+=LOWERCASE_ID? 
	 *         ((elements+=STRING | elements+=LOCALIZED_STRING_REFERENCE)? elements+=LOWERCASE_ID?)*
	 *     )
	 */
	protected void sequence_HeaderRow(ISerializationContext context, HeaderRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     ((literal=Literal | expression=EXPR | variable=LOWERCASE_ID) body=StatementBody elseIfBody+=ElseIfStatementBody* elseCall=StatementBody?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyValuePair returns KeyValuePair
	 *
	 * Constraint:
	 *     (tag=TAG | ((name=LOWERCASE_ID interactive?='?='?)? value=ValueWithConstructor) | key=KEY)
	 */
	protected void sequence_KeyValuePair(ISerializationContext context, KeyValuePair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListElement returns ListElement
	 *
	 * Constraint:
	 *     (value=ValueWithMetadata | tag=TAG)
	 */
	protected void sequence_ListElement(ISerializationContext context, ListElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     contents+=ListElement*
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     (
	 *         number=Number | 
	 *         (from=Number to=Number) | 
	 *         string=STRING | 
	 *         string=LOCALIZED_STRING_REFERENCE | 
	 *         date=Date | 
	 *         boolean='true' | 
	 *         boolean='false'
	 *     )
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupTable returns LookupTable
	 *
	 * Constraint:
	 *     table=Table?
	 */
	protected void sequence_LookupTable(ISerializationContext context, LookupTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntry returns MapEntry
	 *
	 * Constraint:
	 *     (classifier=Classifier value=ValueWithMetadata)
	 */
	protected void sequence_MapEntry(ISerializationContext context, MapEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.MAP_ENTRY__CLASSIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.MAP_ENTRY__CLASSIFIER));
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.MAP_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.MAP_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryAccess().getClassifierClassifierParserRuleCall_0_0(), semanticObject.getClassifier());
		feeder.accept(grammarAccess.getMapEntryAccess().getValueValueWithMetadataParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (entries+=MapEntry entries+=MapEntry*)?
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Match returns Match
	 *
	 * Constraint:
	 *     (
	 *         (id=LOWERCASE_ID body=StatementList) | 
	 *         (annotation=ANNOTATION_ID formalName=LOWERCASE_ID? body=StatementList) | 
	 *         (constant=UPPERCASE_ID body=StatementList) | 
	 *         ((boolean='true' | boolean='false') body=StatementList) | 
	 *         (type=CAMELCASE_ID formalName=LOWERCASE_ID? body=StatementList) | 
	 *         (regexp=REGEXP formalName=LOWERCASE_ID? body=StatementList) | 
	 *         (observable=Observable formalName=LOWERCASE_ID? body=StatementList) | 
	 *         (literal=Literal body=StatementList) | 
	 *         (list=List body=StatementList) | 
	 *         (set=List formalName=LOWERCASE_ID? body=StatementList) | 
	 *         (quantity=Quantity body=StatementList) | 
	 *         (expr=EXPR formalName=LOWERCASE_ID? body=StatementList) | 
	 *         (nodata='unknown' body=StatementList) | 
	 *         (star?='*' body=StatementList) | 
	 *         (anything?='#' body=StatementList) | 
	 *         (empty?='empty' body=StatementList) | 
	 *         (exception?='exception' formalName=LOWERCASE_ID? body=StatementList)
	 *     )
	 */
	protected void sequence_Match(ISerializationContext context, Match semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageBody returns MessageBody
	 *
	 * Constraint:
	 *     lists+=StatementList*
	 */
	protected void sequence_MessageBody(ISerializationContext context, MessageBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageCall returns MessageCall
	 *
	 * Constraint:
	 *     (((name=ArgPathName parameters=ParameterList?) | group=StatementGroup) actions=Actions?)
	 */
	protected void sequence_MessageCall(ISerializationContext context, MessageCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetadataPair returns MetadataPair
	 *
	 * Constraint:
	 *     (key=KEY value=Literal?)
	 */
	protected void sequence_MetadataPair(ISerializationContext context, MetadataPair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metadata returns Metadata
	 *
	 * Constraint:
	 *     pairs+=MetadataPair+
	 */
	protected void sequence_Metadata(ISerializationContext context, Metadata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (preamble=Preamble? definitions+=Definition*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NextStatement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             assignment=Assignment | 
	 *             verb=MessageCall | 
	 *             group=StatementGroup | 
	 *             text=EMBEDDEDTEXT | 
	 *             if=IfStatement | 
	 *             while=WhileStatement | 
	 *             do=DoStatement | 
	 *             for=ForStatement | 
	 *             value=ValueWithMetadata
	 *         ) 
	 *         tag=TAG?
	 *     )
	 */
	protected void sequence_NextStatement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (negative?='-'? real=INT long?='l'? (decimal?='.' decimalPart=INT)? ((exponential?='e' | exponential?='E') expNegative?='-'? exp=INT)?)
	 */
	protected void sequence_Number(ISerializationContext context, org.integratedmodelling.kactors.kactors.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         declaration=ConceptDeclaration 
	 *         (
	 *             (
	 *                 unit=Unit | 
	 *                 currency=Currency | 
	 *                 unit=Unit | 
	 *                 optional?='optional' | 
	 *                 name=LOWERCASE_ID | 
	 *                 name=STRING
	 *             )? 
	 *             (valueOperators+=ValueOperator valueOperators+=ValueOperator*)? 
	 *             (from=Number to=Number)?
	 *         )+
	 *     )
	 */
	protected void sequence_ObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Observable returns Observable
	 *
	 * Constraint:
	 *     observable=ObservableSemantics
	 */
	protected void sequence_Observable(ISerializationContext context, Observable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.OBSERVABLE__OBSERVABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.OBSERVABLE__OBSERVABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObservableAccess().getObservableObservableSemanticsParserRuleCall_1_0(), semanticObject.getObservable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (pairs+=KeyValuePair pairs+=KeyValuePair*)
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Preamble returns Preamble
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 (public?='public'? (mobile?='mobile' | desktop?='desktop' | web?='web')? app?='app') | 
	 *                 test?='testcase' | 
	 *                 script?='script' | 
	 *                 task?='task' | 
	 *                 component?='component' | 
	 *                 user?='user' | 
	 *                 library?='trait' | 
	 *                 library?='library' | 
	 *                 behavior?='behavior' | 
	 *                 behavior?='behaviour'
	 *             ) 
	 *             name=PathName
	 *         )? 
	 *         (label=STRING | label=LOCALIZED_STRING_REFERENCE)? 
	 *         worldview=PathName? 
	 *         (
	 *             (
	 *                 (imports+=PathName imports+=PathName*) | 
	 *                 observable=Observable | 
	 *                 observables=List | 
	 *                 description=STRING | 
	 *                 description=LOCALIZED_STRING_REFERENCE | 
	 *                 permissions=STRING | 
	 *                 permissions=LOCALIZED_STRING_REFERENCE | 
	 *                 authors+=STRING | 
	 *                 authors+=LOCALIZED_STRING_REFERENCE | 
	 *                 (style=PathName inlineStyle=Map?) | 
	 *                 inlineStyle=Map | 
	 *                 logo=Path | 
	 *                 logo=STRING | 
	 *                 logo=LOCALIZED_STRING_REFERENCE | 
	 *                 version=VersionNumber | 
	 *                 versionString=STRING | 
	 *                 locale=LOCALE | 
	 *                 (created=Date createcomment=STRING?) | 
	 *                 (modified=Date modcomment=STRING?)
	 *             )? 
	 *             worldview=PathName?
	 *         )*
	 *     )
	 */
	protected void sequence_Preamble(ISerializationContext context, Preamble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Quantity returns Quantity
	 *
	 * Constraint:
	 *     (value=Number over?='/'? (unit=Unit | currency=Currency))
	 */
	protected void sequence_Quantity(ISerializationContext context, Quantity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     REL_OPERATOR returns REL_OPERATOR
	 *
	 * Constraint:
	 *     (
	 *         gt?='>' | 
	 *         lt?='<' | 
	 *         eq?='=' | 
	 *         ne?='!=' | 
	 *         le?='<=' | 
	 *         ge?='>='
	 *     )
	 */
	protected void sequence_REL_OPERATOR(ISerializationContext context, REL_OPERATOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleConceptDeclaration returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (name=STRING? main+=Concept+)
	 */
	protected void sequence_SimpleConceptDeclaration(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns StatementBody
	 *
	 * Constraint:
	 *     (verb=MessageCall | value=Value | group=StatementGroup)
	 */
	protected void sequence_StatementBody(ISerializationContext context, StatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementGroup returns StatementGroup
	 *
	 * Constraint:
	 *     (body=MessageBody? metadata=Metadata? actions=Actions?)
	 */
	protected void sequence_StatementGroup(ISerializationContext context, StatementGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementList returns StatementList
	 *
	 * Constraint:
	 *     (first=Statement next+=NextStatement*)
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             assignment=Assignment | 
	 *             group=StatementGroup | 
	 *             instantiation=ActorInstantiation | 
	 *             verb=MessageCall | 
	 *             (text=EMBEDDEDTEXT metadata=Metadata?) | 
	 *             if=IfStatement | 
	 *             while=WhileStatement | 
	 *             do=DoStatement | 
	 *             for=ForStatement | 
	 *             value=ValueWithMetadata
	 *         ) 
	 *         tag=TAG?
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableClassifier returns TableClassifier
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         num=Number | 
	 *         string=STRING | 
	 *         observable=Observable | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         set=List | 
	 *         quantity=Quantity | 
	 *         date=Date | 
	 *         expr=EXPR | 
	 *         nodata='unknown' | 
	 *         star?='*' | 
	 *         anything?='#'
	 *     )
	 */
	protected void sequence_TableClassifier(ISerializationContext context, TableClassifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (elements+=TableClassifier elements+=TableClassifier*)
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (headers=HeaderRow? rows+=TableRow rows+=TableRow*)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tree returns Tree
	 *
	 * Constraint:
	 *     (root=ValueWithMetadataWithoutTree (value+=ValueWithMetadataWithoutTree | value+=Tree)+)
	 */
	protected void sequence_Tree(ISerializationContext context, Tree semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns UnitElement
	 *
	 * Constraint:
	 *     (id=CAMELCASE_ID | id=LOWERCASE_ID | id=UPPERCASE_ID | unit=Unit)
	 */
	protected void sequence_UnitElement(ISerializationContext context, UnitElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (root=UnitElement? (connectors+=UnitOp units+=UnitElement)*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueOperator returns ValueOperator
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (modifier=VALUE_OPERATOR | downTo='down') 
	 *             (
	 *                 comparisonValue=Number | 
	 *                 comparisonQuantity=Quantity | 
	 *                 (comparisonConcept+=ConceptDeclaration comparisonConcept+=ConceptDeclaration*) | 
	 *                 comparisonObservable=ObservableSemantics
	 *             )
	 *         ) | 
	 *         total='total' | 
	 *         averaged='averaged' | 
	 *         summed='summed'
	 *     )
	 */
	protected void sequence_ValueOperator(ISerializationContext context, ValueOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueWithConstructor returns Value
	 *
	 * Constraint:
	 *     (
	 *         deferred?='`'? 
	 *         (
	 *             constructor=Constructor | 
	 *             tree=Tree | 
	 *             empty?='empty' | 
	 *             argvalue=ARGVALUE | 
	 *             literal=Literal | 
	 *             urn=UrnId | 
	 *             id=PathName | 
	 *             list=List | 
	 *             map=Map | 
	 *             constant=UPPERCASE_ID | 
	 *             observable=Observable | 
	 *             expression=EXPR | 
	 *             table=LookupTable | 
	 *             quantity=Quantity | 
	 *             (component?='new' behavior=PathName parameters=ParameterList?)
	 *         ) 
	 *         (then=ValueWithConstructor else=ValueWithConstructor)?
	 *     )
	 */
	protected void sequence_ValueWithConstructor(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueWithMetadataWithoutTree returns Value
	 *
	 * Constraint:
	 *     (
	 *         deferred?='`'? 
	 *         (
	 *             argvalue=ARGVALUE | 
	 *             literal=Literal | 
	 *             id=PathName | 
	 *             urn=UrnId | 
	 *             list=List | 
	 *             map=Map | 
	 *             observable=Observable | 
	 *             expression=EXPR | 
	 *             table=LookupTable | 
	 *             quantity=Quantity
	 *         ) 
	 *         (then=Value else=Value)? 
	 *         metadata=Metadata?
	 *     )
	 */
	protected void sequence_ValueWithMetadataWithoutTree(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueWithMetadata returns Value
	 *
	 * Constraint:
	 *     (
	 *         deferred?='`'? 
	 *         (
	 *             tree=Tree | 
	 *             argvalue=ARGVALUE | 
	 *             literal=Literal | 
	 *             urn=UrnId | 
	 *             constant=UPPERCASE_ID | 
	 *             id=PathName | 
	 *             list=List | 
	 *             map=Map | 
	 *             observable=Observable | 
	 *             expression=EXPR | 
	 *             table=LookupTable | 
	 *             quantity=Quantity
	 *         ) 
	 *         metadata=Metadata?
	 *     )
	 */
	protected void sequence_ValueWithMetadata(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (
	 *         deferred?='`'? 
	 *         (
	 *             tree=Tree | 
	 *             empty?='empty' | 
	 *             argvalue=ARGVALUE | 
	 *             urn=UrnId | 
	 *             literal=Literal | 
	 *             id=PathName | 
	 *             list=List | 
	 *             map=Map | 
	 *             constant=UPPERCASE_ID | 
	 *             observable=Observable | 
	 *             expression=EXPR | 
	 *             table=LookupTable | 
	 *             quantity=Quantity
	 *         ) 
	 *         (then=Value else=Value)?
	 *     )
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (expression=EXPR body=StatementBody)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.WHILE_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.WHILE_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.WHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.WHILE_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getExpressionEXPRTerminalRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
