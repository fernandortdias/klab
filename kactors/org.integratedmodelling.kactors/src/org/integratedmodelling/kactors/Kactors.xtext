grammar org.integratedmodelling.kactors.Kactors with org.eclipse.xtext.common.Terminals

generate kactors "http://www.integratedmodelling.org/kactors/Kactors"

Model: {Model}
	(preamble=Preamble)?
	definitions+=Definition*;

Preamble: {Preamble}
	// name, if there, must be first
	('actor' name=PathName)?
	(
		('import' imports+=PathName (',' imports+=PathName)*)? &
		('worldview' worldview=PathName)? &
		('label' label=(LOWERCASE_ID|ID|STRING))? &
		('description' description=STRING)? &
		('permissions' permissions=STRING)? &
		('author' authors+=STRING)* &
		('version' version=VersionNumber)? & 
		('created' created=Date (createcomment=STRING)?)? &
		('modified' modified=Date (modcomment=STRING)?)? 
	)
;	

Definition:
	annotations+=Annotation*
	'message' name=LOWERCASE_ID (arguments=ArgumentDeclaration)? ':' body=Body;

ArgumentDeclaration: {ArgumentDeclaration}
	'(' (ids+=LOWERCASE_ID (',' ids+=LOWERCASE_ID)*)? ')'
;

ParameterList:
	pairs+=KeyValuePair (=> ',' pairs+=KeyValuePair)*;
	
KeyValuePair:
	(name=(LOWERCASE_ID) (interactive?='=?' | '='))?
	value=Value;
	
Value:
	argvalue=ARGVALUE |
	literal=Literal |
	id=PathName |
	urn=UrnId | 
	list=List |
	map=Map |
	observable=OBSERVABLE | 
	expression=EXPR |
	table=LookupTable
	;
	
//Urn:
//	// String used when there are strange chars or keywords in the URN.
//	// In actor files, we should only let in well-formed, lowercase path names
//	name=(PathName|UrnId|STRING)
//;

Annotation:
	name=ANNOTATION_ID ('(' parameters=ParameterList? ')')?;
	
/**
 * URN is 4 sections: node (or 'klab' for internal resources), catalog (or adapter for internal resources), namespace and
 * resource ID. Admits a version number and a fragment (with only lowercase_id chars in it). It is
 * legal, but not required, to start with the default prefix urn:klab:. The 4th path element (the ID) may be
 * integer.
 */
UrnId:
	('urn:klab:')? PathName ':'  PathName ':' PathName ':' (Path|INT) (':' VersionNumber)? ('#' (Path|UrnKvp) ('&' (Path|UrnKvp))*)?;
	
UrnKvp:
	PathName '=' (Path|INT)
;	
	
List:
	{List} '(' contents+=Value* ')';
	
Map:
	{Map} '{' (entries+=MapEntry (=> (',') entries+=MapEntry)*)? '}'
;

MapEntry:
	classifier=Classifier ':' value=Value
;	

Classifier:
	(boolean='true' | boolean='false') | 
	int0=Number (leftLimit='inclusive' | 'exclusive')? => 'to' => int1=Number (rightLimit='inclusive' | 'exclusive')? |
	num=Number | 
	'in' set=List | 
	string=STRING | 
	observable=OBSERVABLE | 
	id = LOWERCASE_ID |
	op=REL_OPERATOR expression=Number | 
	nodata='unknown' |
	star?='*';	

// Lookup table literal. May be overkill.
LookupTable: {LookupTable}
	'{{' table=Table? '}}'
;

Table:
	(headers=HeaderRow SEPARATOR)? rows+=TableRow (',' rows+=TableRow)*;

HeaderRow:
	elements+=(LOWERCASE_ID|STRING) ('|' elements+=(LOWERCASE_ID|STRING))*
;

TableRow:
	elements+=TableClassifier ('|' elements+=TableClassifier)*
;

TableClassifier:
	(boolean='true' | boolean='false') | 
	num=Number | 
	string=STRING | 
	observable=OBSERVABLE | 
	op=REL_OPERATOR expression=Number | 
	int0=Number (leftLimit='inclusive' | 'exclusive')? => 'to' => int1=Number (rightLimit='inclusive' | 'exclusive')? |
	'in' set=List | 
	quantity=Quantity |
	date=Date |
	expr=EXPR |
	nodata='unknown' |
	star?='*' |
	anything?='#';

Quantity:
	value=Number (over?='/' | '.') (unit=Unit | currency=Currency)
;

UnitElement:
	id=(CAMELCASE_ID|LOWERCASE_ID|UPPERCASE_ID) |
	'(' unit=Unit ')';

enum UnitOp:
	OVER='/' | CARET='^' | STAR='*';

Unit:
	{Unit} (root=UnitElement)? (=> (connectors+=UnitOp) (units+=UnitElement))*;

Currency:
	id=UPPERCASE_ID ('@' year=INT) (=> '/' (units+=UnitElement))*;
		
REL_OPERATOR:
	(gt?='>' |
	lt?='<' |
	eq?='=' |
	ne?='!=' |
	le?='<=' |
	ge?='>=');
	
Literal:
	number=Number | from=Number 'to' to=Number | string=STRING | date=Date | boolean=('true' | 'false');

//// only missing piece: mix statement and groups in group, which probably makes no sense so OK.
Body: {Body} lists+=StatementList*;

Verb:
	(name=PathName ('(' (parameters=ParameterList)? ')')? |
	  Group) ((':' actions=Actions) | ';')?
;

Group: {Group}
	'(' body=Body? ')'
;

StatementList:
	first=Statement next+=NextStatement*
;

Statement:
	verb=Verb |
	group=Group |
	text=EMBEDDEDTEXT |
	if=IfStatement |
	while=WhileStatement |
	do=DoStatement |
	for=ForStatement
;

NextStatement returns Statement:
	',' (
		verb=Verb |
		group=Group |
		text=EMBEDDEDTEXT |
		if=IfStatement |
		while=WhileStatement |
		do=DoStatement |
		for=ForStatement
	)
;

IfStatement:
	'if' expression=EXPR body=IfBody	
		('else' 'if' elseIfExpression+=EXPR elseIfCall+=IfBody)* 
		('else' elseCall=IfBody)?
;

IfBody: verb=Verb | group=Group;

WhileStatement:
	'while' expression=EXPR body=IfBody
;

DoStatement:
	'do' body=IfBody 'while' expression=EXPR
;

ForStatement:
	'for' (id=LOWERCASE_ID 'in')? value=Value body=IfBody
;

// a sequence of actions after a verb is sequential only if comma-separated. No match mean
// "upon successful firing" (i.e. firing not null, false or error).
Actions: 
	statement=Statement |
	'(' statements=StatementList ')' |
	match=Match |
	'(' matches+=Match (matches+=Match)* ')'
;

Match:
	id?=LOWERCASE_ID '->' body=StatementList |
	type?=CAMELCASE_ID '->' body=StatementList |
	regexp?=REGEXP '->' body=StatementList |
	observable?=OBSERVABLE '->' body=StatementList |
	literal?=Literal '->' body=StatementList |
	text?=STRING '->' body=StatementList |
	arguments=ArgumentDeclaration '->' body=StatementList |
	int0=Number (leftLimit='inclusive' | 'exclusive')? => 'to' => int1=Number (rightLimit='inclusive' | 'exclusive')? '->' body=StatementList |
	'in' set=List '->' body=StatementList | 
	quantity=Quantity '->' body=StatementList |
	date=Date '->' body=StatementList |
	expr=EXPR '->' body=StatementList |
	nodata='unknown' '->' body=StatementList |
	star?='*' '->' body=StatementList |
	anything?='#''->' body=StatementList 
;

Number:
	('+' | negative?='-')? => real=INT (=> long?='l')? => (decimal?='.' decimalPart=INT)? => (exponential?=('e' | 'E') ('+' | expNegative?='-')? exp=INT)?;

Date:
	year=INT ('AD' | 'CE' | bc?='BC')? '-' month=INT '-' day=INT (hour=INT ':' min=INT (':' sec=INT ('.' ms=INT)?)?)?
;

PathName:
	LOWERCASE_ID ('.' LOWERCASE_ID)*
;

Path:
	(LOWERCASE_ID|UPPERCASE_ID) (('.' | '/') (LOWERCASE_ID|UPPERCASE_ID))*
;

terminal UPPERCASE_ID:
	('A'..'Z') ('A'..'Z' | '_')*;

terminal UPPERCASE_PATH:
	UPPERCASE_ID ('.' UPPERCASE_ID)*;

terminal CAMELCASE_ID:
	('A'..'Z') ('A'..'z'|'0'..'9')*;

VersionNumber:
	INT ('.' INT ('.' INT)?)? ('-')? ((LOWERCASE_ID|UPPERCASE_ID))?;

terminal LOWERCASE_ID:
	('a'..'z') ('a'..'z' | '0'..'9'| '_')*;

terminal ARGVALUE:
	'$' ('0'..'9')*;

terminal EXPR:
	'[' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | ']' | '\\') | !('\\' | ']'))* ']';
	
terminal EMBEDDEDTEXT:
	'%%%'((' ')*'-')*'\r' -> '%%%'((' ')*'-')*;

terminal REGEXP:
	'%' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '%' | '\\') | !('\\' | '%'))* '%';
	
terminal OBSERVABLE:
	'{' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '\\') | !('\\' | '}'))* '}';
		
terminal SEPARATOR:
	'---' ('-')*;

terminal ANNOTATION_ID:
	'@' LOWERCASE_ID;