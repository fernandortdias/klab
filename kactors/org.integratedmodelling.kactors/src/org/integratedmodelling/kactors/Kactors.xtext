grammar org.integratedmodelling.kactors.Kactors with org.eclipse.xtext.common.Terminals

generate kactors "http://www.integratedmodelling.org/kactors/Kactors"

Model: {Model}
	(preamble=Preamble)?
	definitions+=Definition*;

Preamble: {Preamble}
	// name, if there, must be first
	('name' name=PathName)?
	(
		('import' imports+=PathName (',' imports+=PathName)*)? &
		('worldview' worldview=PathName)? &
		('label' label=(LOWERCASE_ID|ID|STRING))? &
		('description' description=STRING)? &
		('permissions' permissions=STRING)? &
		('author' authors+=STRING)* &
		('version' version=VersionNumber)? & 
		('created' created=Date (createcomment=STRING)?)? &
		('modified' modified=Date (modcomment=STRING)?)? 
	)
;	

Definition:
	annotations+=Annotation*
	'def' name=LOWERCASE_ID (arguments=ArgumentDeclaration)? ':' body+=Body+;

ArgumentDeclaration: {ArgumentDeclaration}
	'(' (ids+=LOWERCASE_ID (',' ids+=LOWERCASE_ID)*)? ')'
;

ParameterList:
	pairs+=KeyValuePair (=> ',' pairs+=KeyValuePair)*;
	
KeyValuePair:
	(name=(LOWERCASE_ID) (interactive?='=?' | '='))?
	value=Value;
	
Value:
	argvalue=ARGVALUE |
	literal=Literal |
	id=LOWERCASE_ID |
	urn=Urn | 
	list=List |
	map=Map |
	observable=OBSERVABLE | 
	expression=EXPR |
	table=LookupTable
	;
	
Urn:
	// String used when there are strange chars or keywords in the URN.
	// In actor files, we should only let in well-formed, lowercase path names
	name=(PathName|UrnId|STRING)
;

Annotation:
	name=ANNOTATION_ID ('(' parameters=ParameterList? ')')?;
	
/**
 * URN is 4 sections: node (or 'klab' for internal resources), catalog (or adapter for internal resources), namespace and
 * resource ID. Admits a version number and a fragment (with only lowercase_id chars in it). It is
 * legal, but not required, to start with the default prefix urn:klab:. The 4th path element (the ID) may be
 * integer.
 */
UrnId:
	('urn:klab:')? PathName ':'  PathName ':' PathName ':' (Path|INT) (':' VersionNumber)? ('#' (Path|UrnKvp) ('&' (Path|UrnKvp))*)?;
	
UrnKvp:
	PathName '=' (Path|INT)
;	
	
List:
	{List} '(' contents+=Value* ')';
	
Map:
	{Map} '{' (entries+=MapEntry (=> (',') entries+=MapEntry)*)? '}'
;

MapEntry:
	classifier=Classifier ':' value=Value
;	

Classifier:
	(boolean='true' | boolean='false') | 
	int0=Number (leftLimit='inclusive' | 'exclusive')? => 'to' => int1=Number (rightLimit='inclusive' | 'exclusive')? |
	num=Number | 
	'in' set=List | 
	string=STRING | 
	observable=OBSERVABLE | 
	id = LOWERCASE_ID |
	op=REL_OPERATOR expression=Number | 
	nodata='unknown' |
	star?='*';	

// Lookup table literal. May be overkill.
LookupTable: {LookupTable}
	'{{' table=Table? '}}'
;

Table:
	(headers=HeaderRow SEPARATOR)? rows+=TableRow (',' rows+=TableRow)*;

HeaderRow:
	elements+=(LOWERCASE_ID|STRING) ('|' elements+=(LOWERCASE_ID|STRING))*
;

TableRow:
	elements+=TableClassifier ('|' elements+=TableClassifier)*
;

TableClassifier:
	(boolean='true' | boolean='false') | 
	num=Number | 
	string=STRING | 
	observable=OBSERVABLE | 
	op=REL_OPERATOR expression=Number | 
	int0=Number (leftLimit='inclusive' | 'exclusive')? => 'to' => int1=Number (rightLimit='inclusive' | 'exclusive')? |
	'in' set=List | 
	quantity=Quantity |
	date=Date |
	expr=EXPR |
	nodata='unknown' |
	star?='*' |
	anything?='#';

Quantity:
	value=Number (over?='/' | '.') (unit=Unit | currency=Currency)
;

UnitElement:
	id=(CAMELCASE_ID|LOWERCASE_ID|UPPERCASE_ID) |
	'(' unit=Unit ')';

enum UnitOp:
	OVER='/' | CARET='^' | STAR='*';

Unit:
	{Unit} (root=UnitElement)? (=> (connectors+=UnitOp) (units+=UnitElement))*;

Currency:
	id=UPPERCASE_ID ('@' year=INT) (=> '/' (units+=UnitElement))*;
		
REL_OPERATOR:
	(gt?='>' |
	lt?='<' |
	eq?='=' |
	ne?='!=' |
	le?='<=' |
	ge?='>=');
	
Literal:
	number=Number | from=Number 'to' to=Number | string=STRING | date=Date | boolean=('true' | 'false');

Body: {Body}
	list+=Statement (list+=Statement)* |
	// only way to be empty is to be an empty group
	isgroup?='(' (group+=Statement (group += Statement)*)? ')'
;

Statement:
	call=Call |
	text=EMBEDDEDTEXT |
	if=IfStatement |
	'(' group+=Statement (group+=Statement)* ')'
	while=WhileStatement |
	do=DoStatement |
	for=ForStatement
;

IfStatement:
	'if' expression=EXPR body=IfBody	
		('else' 'if' elseIfExpression+=EXPR elseIfCall+=IfBody)* 
		('else' elseCall=IfBody)?
;

IfBody:
	call=Call |
	'(' body+=Body+ ')'
;

WhileStatement:
	'while' expression=EXPR body=IfBody
;

DoStatement:
	'do' body=IfBody 'while' expression=EXPR
;

ForStatement:
	'for' (id=LOWERCASE_ID 'in')? value=Value body=IfBody
;

Call:
	name=LOWERCASE_ID ('(' (parameters=ParameterList)? ')')? ((':' actions=Actions) | ';')? 
;

Actions: 
	call=Call |
	body=Body |
	match=Match |
	'(' matches+=Match (matches+=Match)* ')'
;

Match:
	id?=LOWERCASE_ID '->' body=Body |
	regexp?=REGEXP '->' body=Body |
	observable?=OBSERVABLE '->' body=Body |
	literal?=Literal '->' body=Body |
	text?=STRING '->' body=Body |
	arguments=ArgumentDeclaration '->' body=Body |
	int0=Number (leftLimit='inclusive' | 'exclusive')? => 'to' => int1=Number (rightLimit='inclusive' | 'exclusive')? '->' body=Body |
	'in' set=List '->' body=Body | 
	quantity=Quantity '->' body=Body |
	date=Date '->' body=Body |
	expr=EXPR '->' body=Body |
	nodata='unknown' '->' body=Body |
	star?='*' '->' body=Body |
	anything?='#''->' body=Body 
;

Number:
	('+' | negative?='-')? => real=INT (=> long?='l')? => (decimal?='.' decimalPart=INT)? => (exponential?=('e' | 'E') ('+' | expNegative?='-')? exp=INT)?;

Date:
	year=INT ('AD' | 'CE' | bc?='BC')? '-' month=INT '-' day=INT (hour=INT ':' min=INT (':' sec=INT ('.' ms=INT)?)?)?
;

PathName:
	LOWERCASE_ID ('.' LOWERCASE_ID)*
;

Path:
	(LOWERCASE_ID|UPPERCASE_ID) (('.' | '/') (LOWERCASE_ID|UPPERCASE_ID))*
;

terminal UPPERCASE_ID:
	('A'..'Z') ('A'..'Z' | '_')*;

terminal UPPERCASE_PATH:
	UPPERCASE_ID ('.' UPPERCASE_ID)*;

terminal CAMELCASE_ID:
	('A'..'Z') ('A'..'z'|'0'..'9')*;

VersionNumber:
	INT ('.' INT ('.' INT)?)? ('-')? ((LOWERCASE_ID|UPPERCASE_ID))?;

terminal LOWERCASE_ID:
	('a'..'z') ('a'..'z' | '0'..'9'| '_')*;

terminal ARGVALUE:
	'$' ('0'..'9')*;

terminal EXPR:
	'[' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | ']' | '\\') | !('\\' | ']'))* ']';
	
terminal EMBEDDEDTEXT:
	'%%%'((' ')*'-')*'\r' -> '%%%'((' ')*'-')*'\r';

terminal REGEXP:
	'%' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '%' | '\\') | !('\\' | '%'))* '%';
	
terminal OBSERVABLE:
	'{' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '\\') | !('\\' | '}'))* '}';
		
terminal SEPARATOR:
	'---' ('-')*;

terminal ANNOTATION_ID:
	'@' LOWERCASE_ID;