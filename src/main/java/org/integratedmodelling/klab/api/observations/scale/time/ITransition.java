/*******************************************************************************
 * Copyright (C) 2007, 2015:
 * 
 * - Ferdinando Villa <ferdinando.villa@bc3research.org> - integratedmodelling.org - any
 * other authors listed in @author annotations
 *
 * All rights reserved. This file is part of the k.LAB software suite, meant to enable
 * modular, collaborative, integrated development of interoperable data and model
 * components. For details, see http://integratedmodelling.org.
 * 
 * This program is free software; you can redistribute it and/or modify it under the terms
 * of the Affero General Public License Version 3 or any later version.
 *
 * This program is distributed in the hope that it will be useful, but without any
 * warranty; without even the implied warranty of merchantability or fitness for a
 * particular purpose. See the Affero General Public License for more details.
 * 
 * You should have received a copy of the Affero General Public License along with this
 * program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite
 * 330, Boston, MA 02111-1307, USA. The license is also available at:
 * https://www.gnu.org/licenses/agpl.html
 *******************************************************************************/
package org.integratedmodelling.klab.api.observations.scale.time;

import java.util.Collection;

import org.integratedmodelling.klab.api.observations.IObservation;
import org.integratedmodelling.klab.api.observations.scale.IScale;
import org.integratedmodelling.klab.api.observations.scale.IScale.Locator;

/**
 * A transition is a (small, fast) object that is generated by confronting a schedule
 * event with an IObservationContext.
 * 
 * TODO ITransition should be linked to IScale - and like it, have conceptually indexed
 * "dimensions" for time, space and whatever else. Transitions only happen if time changes
 * (that's a physical necessity for the transition to be "seen" by an agent) but may bring
 * other changes with them. So a transition is a container just like scale contains
 * extents. Each piece of a transition will be an extent, contained within the main extent
 * in the scale.
 *
 * The transition is indeed a IScale - that's what it is, except it may have null extents
 * for dimensions that have not changed in time.
 *
 * @author Ferd
 *
 */
public interface ITransition extends IScale, Locator {

    /**
     * Initialization transition, passed to resolution strategies before time exists.
     * Simply a null, may change in the future.
     */
    public static ITransition INITIALIZATION = null;

    /**
     * Should the agent remain alive/valid beyond this transition?
     * 
     * @return true if the agent survives; false if this transition causes the agent to
     *         die
     * 
     *         FIXME this should probably be a special subtype of transition rather than
     *         sticking this flag in every transition
     */
    boolean agentSurvives();

//    /**
//     * TODO this needs to change so that diffs can be processed directly, instead of full
//     * state objects FIXME this API feels a bit raw as of now. Most of these methods
//     * should not really be part of the transition itself.
//     * 
//     * @return agent state
//     */
//    IAgentState getAgentState();
//
//    /**
//     * get any further observations which are implied by-products of this observation.
//     *
//     * For instance, an agent which is still alive after the time interval (t,t+1] will
//     * require the next time interval (t+1,t+2] to be observed. Another example would be
//     * an object in motion which requires collision detection to be performed.
//     *
//     * The type(s) of IObservationTask which are included will indicate what actions are
//     * taken. The main categories are: 1) observing the next agent-state of this agent,
//     * and 2) creating a new agent by making an initial observation of it. (Message
//     * sending will be subclasses of the second type.)
//     * 
//     * @return remaining tasks
//     */
//    Collection<IObservationTask> getFurtherObservationTasks();
//
//    void addFurtherObservationTask(IObservationTask subsequentTaskForThisAgent);
//
//    /**
//     * Return a list of agent states which were observed during this observation.
//     *
//     * The ITimeInstant which is returned should be the time for which each dependency was
//     * observed. This is because an agent is allowed to "query the past" if it so desires,
//     * and therefore the agent's decision time might be different than the query time for
//     * the dependency.
//     *
//     * By recording these causal relationships, we can invalidate observations if the
//     * underlying states become invalid.
//     *
//     * @return dependencies
//     */
//    Collection<Pair<ITimeInstant, IObservationGraphNode>> getObservationDependencies();

    /**
     * Return if this transition is the last to be called. If so, services for the given
     * context will be garbage collected and logging may take place. Returning true before
     * it's time will result in horror; returning false when it's over will result in lots
     * of memory being wasted.
     * 
     * TODO check overlap with agentSurvives() if we decide to keep it in the base class.
     * This one should return true after contextualization is over.
     * 
     * @return true if last
     */
    boolean isLast();

    /**
     * The linear index in the time dimension that corresponds to this transition. If this
     * returns -1, we have no time or this is an initialization transition.
     * 
     * @return linear index in time extent
     */
    int getTimeIndex();

    /**
     * Any observation created or modified by this transition should be available here
     * after the transition has been processed.
     * 
     * @return modified observations
     */
    Collection<IObservation> getModifiedObservations();

    /**
     * Return the previous transition. If this is the first transition, null (interpreted
     * as initialization by the API) is returned.
     * 
     * @return previous transition
     */
    ITransition previous();

    /**
     * Return the transition at a previous time. Should accept time extents, points, and
     * integers for discrete selection. previous() is equivalent to previous(1).
     * 
     * @param locator
     * @return previous at passed locator
     */
    ITransition previous(Object locator);

    /**
     * Return the next transition, if any. Should throw a runtime exception if next() is
     * called on the last transition - check that with isLast() if needed.
     * 
     * @return next transition
     */
    ITransition next();
}
